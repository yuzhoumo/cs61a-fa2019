<!DOCTYPE html>
<html>
<head>
    <title>Homework 7 | CS 61B Spring 2020</title>
    <meta charset="UTF-8">

    
    <link href="https://fonts.googleapis.com/css?family=Open+Sans:300,400,600" rel="stylesheet" type="text/css">
    <link href="../../../assets/css/common.css" rel="stylesheet" type="text/css">
    <link href="../../../assets/css/lab.css" rel="stylesheet" type="text/css">
    <link href="../../../assets/css/highlight/styles/tomorrow.css" rel="stylesheet" type="text/css">
    
    <script src="../../../assets/js/jquery-1.12.4.min.js" type="text/javascript"></script>
    <script src="../../../assets/css/highlight/highlight.pack.js" type="text/javascript"></script> 
    <script src="../../../assets/js/sidebar.js" type="text/javascript"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script type="text/x-mathjax-config">
MathJax.Hub.Config({

    tex2jax: {inlineMath: [["$", "$"]]}
})
   
</script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_HTML-full"></script>
</head>
<body>
    <div class="navbar-top"><div id="navitems">
        <a href="../../../index.html"><div class="navitem">Main</div></a>
        <a href="../../../about.html"><div class="navitem">Course Info</div></a>
        <a href="../../../staff.html"><div class="navitem">Staff</div></a>
        <!--<a href="../../../assign.html"><div class="navitem">Assignments</div></a>-->
        <a href="../../../../../../auth.berkeley.edu/cas/login%3Fservice=https:%252F%252Finst.EECS.Berkeley.EDU%252F~cs61b%252Fsp20%252Fscreencasts.html" target="_blank"><div class="navitem">Screencasts</div></a>
        <a href="../../../../../../auth.berkeley.edu/cas/login%3Fservice=https:%252F%252Finst.EECS.Berkeley.EDU%252F~cs61b%252Fsp20%252Fcgi-bin%252Fcalnet-auth-scores.cgi.html" target="_blank"><div class="navitem">Scores</div></a>
        <a href="../../../resources.html"><div class="navitem">Resources</div></a>
        <a href="https://piazza.com/class/jkx2gta66436jq"><div class="navitem">Piazza</div></a>
    </div></div>
    <div id="sidebar">
        <div id="sidebar-content">
            <h3>Navigation</h3>
            <ul>
  <li><a href="index.html#navigation">Navigation</a></li>
  <li><a href="index.html#a-implementing-sorting-algorithms">A. Implementing Sorting Algorithms</a></li>
  <li><a href="index.html#b-quicksort-and-mergesort-mechanics">B. Quicksort and Mergesort Mechanics</a></li>
  <li><a href="index.html#c-sorting-problems">C. Sorting Problems</a></li>
  <ul>
    <li><a href="index.html#intervals-intervals-java">Intervals (Intervals.java)</a></li>
    <li><a href="index.html#distribution-count-for-large-numbers-sortints-java">Distribution Count for Large Numbers (SortInts.java)</a></li>
    <li><a href="index.html#inversion-counting-inversions-java">Inversion Counting (Inversions.java)</a></li>
    <li><a href="index.html#two-sum-sum-java">Two Sum (Sum.java)</a></li>
  </ul>
  <li><a href="index.html#d-submission">D. Submission</a></li>
</ul>
        </div>
    </div>
    <div id="content-container"><main id="content">
        <header class="title">Homework 7: A Balanced Variety of all Sorts of Fun!</header>
        
<p>This homework is intended to give you a chance to better understand
sorting and balanced search trees.</p>


<h2 id="navigation">Navigation</h2>


<ul>
  <li><a href="index.html#a-implementing-sorting-algorithms">A. Implementing Sorting Algorithms</a></li>
  <li><a href="index.html#b-quicksort-and-mergesort-mechanics">B. Quicksort and Mergesort Mechanics</a></li>
  <li><a href="index.html#c-sorting-problems">C. Sorting Problems</a></li>
  <li><a href="index.html#d-submission">D. Submission</a></li>
</ul>


<h2 id="a-implementing-sorting-algorithms">A. Implementing Sorting Algorithms</h2>


<p>The skeleton, <code>MySortingAlgorithms.java</code>
provides a template for implementing various sorting algorithms.</p>

<p>Open <code>SortingAlgorithm.java</code> to see the interface you will have to satisfy. Note that every child class's sort method takes in an argument k. The sorting algorithm should sort the array from index 0 to k. 
Hint: This argument could be useful for some of your sorts.</p>

<p>Implement the algorithms below (the ones with an asterisk next to it
are required for this assignment). Note that an implementation of <code>Quicksort.java</code> has been provided. Clicking on the links will take you to 
an animation of the sort to refresh your memory.</p>

<ul>
  <li>*<a href="https://www.youtube.com/watch?v=kPRA0W1kECg">Selection sort</a>: Easier</li>
  <li>*<a href="https://www.youtube.com/watch?v=kPRA0W1kECg&t=0m9s">Insertion sort</a>: Easier</li>
  <li>*<a href="https://www.youtube.com/watch?v=kPRA0W1kECg&t=1m05s">Mergesort</a>: Moderate</li>
  <li>Counting sort: Moderate</li>
  <li><a href="https://www.youtube.com/watch?v=kPRA0W1kECg&t=1m28s">Heapsort</a>: Harder</li>
  <li><a href="https://www.youtube.com/watch?v=kPRA0W1kECg&t=0m38s">Quicksort</a>: Harder</li>
  <li>*<a href="https://www.youtube.com/watch?v=kPRA0W1kECg&t=1m54s">LSD radix sort</a>: Harder</li>
  <li>MSD radix sort: Harder</li>
</ul>

<p>Conceptual videos:</p>

<ul>
  <li>General sorting overview: <a href="https://youtu.be/EegsIk43Da4">here</a></li>
  <li>Mergesort: <a href="https://youtu.be/P7pD-BCt3Y4">here</a></li>
  <li>Quicksort: <a href="https://youtu.be/BrVvQAatO0s">here</a></li>
  <li>General Radix sort: <a href="https://youtu.be/0QBWYfIrPs0">here</a></li>
  <li>LSD sort: <a href="https://youtu.be/k979yw8Ng9M">here</a></li>
</ul>

<p>You can use <code>MySortingAlgorithmsTest.java</code> to test your implementations.</p>

<hr/>

<p>Once you're done, here are some questions to ponder (you don't need to
record nor submit your responses):</p>

<ul>
  <li>How many items are sorted in the video for selection sort?</li>
  <li>Why does insertion sort take longer/more compares than selection sort?</li>
  <li>At what time stamp does the first partition complete for Quicksort?</li>
  <li>Could the size of the input used by mergesort in the video be a power of 2?</li>
  <li>What do the colors mean for heapsort?</li>
  <li>How many characters are in the alphabet used for the LSD sort problem?</li>
  <li>How many digits are in the keys used for the LSD sort problem?</li>
  <li>The complete video ends with a rather odd sort that doesn't complete.
  Without
  looking at the captions, can you tell what it's doing?</li>
  <li>How does the standard sort from the GCC library, a form of quicksort,
  differ from the other version of quicksort shown?</li>
</ul>

<hr/>

<p>Additionally, the <code>RunBenchmarks</code> class runs timing tests on our
various sorts.  Currently, it is configured to perform two timing
tests:</p>

<ul>
  <li>Compare (y)our implementation against Arrays.sort (which uses
  <code>Quicksort</code> for ints).</li>
  <li>Time insertion sort for almost sorted arrays.</li>
</ul>

<p>Run the code, and you should see results that are in line with things
we've learned in class.</p>

<p>If the second test takes too long to complete, you can "Edit
Configurations" in IntelliJ and type a number for program arguments to
run the test on a smaller input size.</p>

<p>Other interesting tests you might try:</p>

<ul>
  <li>How do LSD and MSD compare with Quicksort and Mergesort? How large
  must N be before they become faster?</li>
  <li>Find a case where LSD is faster than MSD.</li>
  <li>For what N is insertion sort faster than Quicksort?</li>
  <li>How do selection sort and insertion sort compare?</li>
</ul>

<p>Feel free to post interesting tests and/or observations on Piazza. You
do <em>not</em> need to submit anything related to this Benchmark test.</p>


<h2 id="b-quicksort-and-mergesort-mechanics">B. Quicksort and Mergesort Mechanics</h2>


<p>Interestingly enough, quicksorting an array is equivalent to inserting
all of its items into a BST.  In this problem, we'll see why.</p>

<p>First, we need a specific implementation for partitioning.</p>

<p>Consider the array <code>[5, 3, 2, 1, 7, 8, 4, 6]</code>, and suppose that
we pick the leftmost item 5 as our pivot. One approach to partitioning
is to perform a "stable" partitioning where all items that are less
than 5 appear in the same order as they did before partitioning, and
likewise for the greater items. For the given array, we'd get <code>[3,
2, 1, 4, 5, 7, 8, 6]</code>.</p>

<p>One inefficient but simple way to implement this stable partitioning
algorithm is to perform the following steps:</p>

<ul>
  <li>Create three empty Lists for storing integers smaller, equal to, and
  larger than the pivot, respectively.</li>
  <li>Go through each item of the list, comparing it to the pivot, and
  adding items to the respective list based on the comparison.</li>
  <li>Concatenting the three Lists into a single concatenated List.</li>
  <li>Copying the concatenated List back into the array.</li>
</ul>

<p>So for example if we partition <code>[5, 3, 2, 1, 7, 8, 4, 6]</code> from index 0
to index 7, we'd get:</p>

<pre><code>Smaller items: [3, 2, 1, 4]
Equal items  : [5]
Larger items : [7, 8, 6]</code></pre>

<p>The concatenation of these lists is just <code>[3, 2, 1, 4, 5, 7, 8, 6]</code>.
Along the way, we compared the following pairs of numbers: <code>5&#x2d;3, 5&#x2d;2,
5&#x2d;1, 5&#x2d;4, 5&#x2d;7, 5&#x2d;8,</code> and <code>5&#x2d;6</code>.</p>

<p>If we are using partition to sort, we then repeat this process for
the left half and right half sides as discussed in class.</p>

<p>In <code>HW7 Written</code> on gradescope, fill out the list of comparisons used by
Quicksort. You might find running the provided <code>Quicksort.java</code> to
be useful. You may also want to draw the BST that results when you insert <code>[5, 3, 2, 1, 7, 8, 4, 6]</code> (in that order) into an initially empty BST.
You can submit the gradescope assignment more than once.</p>


<h2 id="c-sorting-problems">C. Sorting Problems</h2>


<p>There are many problems for which sorting provides a fast solution,
even though the problem isn't really about sorting. We encourage you
to do all of these, but you only need to do any one of them for full
credit.</p>


<h3 id="intervals-intervals-java">Intervals (Intervals.java)</h3>

<p>Define an interval to be a pair of numbers $[x_i, x_i&#x27;]$ such
that $x_i < x_i&#x27;$. An interval specifies a range of values in
1D space, where we can call $x_i$ the start point, and
$x_i&#x27;$ the end point.</p>

<p>Given a list of such intervals, we want to know the total length of
the regions covered by one or more of the intervals.  This is not
simply the sum of their lengths, $\Sigma x_i&#x27; - x_i$, since
several may cover the same span.</p>

<p>For example, if we have intervals $[19, 30]$, $[6,
12]$, $[4, 5]$, $[8, 15]$, and $[3,
10]$, then the total length covered is 23: the last four
intervals together totally cover the interval $[3, 15]$ of
length 12, and the first covers a disjoint interval of length 11.</p>

<p>Fill in <code>Intervals.java</code> so that the <code>coveredLength</code> method returns the
correct total length in $\Theta(N log N)$ time.</p>

<p>There is a clever trick to this problem that you'll need to figure out
to get $\Theta(N log N)$ time. You do not need to use any
nested loops for this problem, and in fact if you find yourself using
them, you probably haven't found the right approach.</p>


<h3 id="distribution-count-for-large-numbers-sortints-java">Distribution Count for Large Numbers (SortInts.java)</h3>


<p>[Goodrich &amp; Tamassia] Given a sequence of n distinct integers, each
one of which is in the range $[0, n^2 - 1]$, develop an
$O(n)$ algorithm for sorting them. See the skeleton file
SortInts.java. You can't use ordinary distribution sort for this,
because that would require initializing and traversing arrays of size
$n^2$, which would take too long</p>


<h3 id="inversion-counting-inversions-java">Inversion Counting (Inversions.java)</h3>


<p>Find an algorithm that runs in $O(n \lg n)$ time for
computing the number of inversions in a list of n items. Array
elements that are "out of order" can be corrected by swapping two
adjacent elements at a time, each of which counts as a single
inversion. See the skeleton file Inversions.java. To test that your
code is actually $O(n \lg n)$, provide it a very large list
(say hundreds of thousands).</p>


<h3 id="two-sum-sum-java">Two Sum (Sum.java)</h3>


<p>[Goodrich &amp; Tamassia] Given two sequences of integers, $A$
and $B$, find an algorithm that runs in $O(n \lg n)$
time (where n is the total number of integers in A and B) that
determines, for a given parameter $m$, whether there is an
integer $a$ in $A$ and an integer $b$ in
$B$ such that $m = a + b$. See the skeleton file
<code>Sum.java</code>. To test that your algorithm runs in $O(n \lg n)$
time, provide sequences of hundreds of thousands of integers. Feel
free to use any of the methods in java.util.Arrays.</p>


<h2 id="d-submission">D. Submission</h2>


<p>You will be required to submit:</p>

<ol>
  <li><code>MySortingAlgorithms.java</code> with Selection Sort, Insertion Sort,
  Mergesort, and LSD Radix Sort implemented.</li>
  <li><code>HW7 Written</code> on gradescope.</li>
  <li>At least one of <code>Intervals.java</code>, <code>SortInts.java</code>, <code>Inversions.java</code>, and <code>Sum.java</code>.  (We suggest you attempt all of them, however.)</li>
</ol>

<p>Don't forget to push both your commits and tags for your final submission. As a reminder, you can push your tags by running:</p>

<pre><code>$ git push &#x2d;&#x2d;tags</code></pre>
    </main></div>
</body>
</html>
