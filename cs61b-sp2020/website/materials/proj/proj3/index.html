<!DOCTYPE html>
<html>
<head>
    <title>Project 3 | CS 61B Spring 2020</title>
    <meta charset="UTF-8">

    


    <link href="https://fonts.googleapis.com/css?family=Open+Sans:300,400,600" rel="stylesheet" type="text/css">
    <link href="../../../assets/css/common.css" rel="stylesheet" type="text/css">
    <link href="../../../assets/css/lab.css" rel="stylesheet" type="text/css">
    <link href="../../../assets/css/highlight/styles/tomorrow.css" rel="stylesheet" type="text/css">
    
    <link href="../../../assets/css/proj.css" rel="stylesheet" type="text/css">

    <script src="../../../assets/js/jquery-1.12.4.min.js" type="text/javascript"></script>
    <script src="../../../assets/css/highlight/highlight.pack.js" type="text/javascript"></script> 
    <script src="../../../assets/js/sidebar.js" type="text/javascript"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script type="text/x-mathjax-config">
MathJax.Hub.Config({

    tex2jax: {inlineMath: [["$", "$"]]}
})
   
</script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_HTML-full"></script>
</head>
<body>
    <div class="navbar-top"><div id="navitems">
        <a href="../../../index.html"><div class="navitem">Main</div></a>
        <a href="../../../about.html"><div class="navitem">Course Info</div></a>
        <a href="../../../staff.html"><div class="navitem">Staff</div></a>
        <!--<a href="../../../assign.html"><div class="navitem">Assignments</div></a>-->
        <a href="../../../../../../auth.berkeley.edu/cas/login%3Fservice=https:%252F%252Finst.EECS.Berkeley.EDU%252F~cs61b%252Fsp20%252Fscreencasts.html" target="_blank"><div class="navitem">Screencasts</div></a>
        <a href="../../../../../../auth.berkeley.edu/cas/login%3Fservice=https:%252F%252Finst.EECS.Berkeley.EDU%252F~cs61b%252Fsp20%252Fcgi-bin%252Fcalnet-auth-scores.cgi.html" target="_blank"><div class="navitem">Scores</div></a>
        <a href="../../../resources.html"><div class="navitem">Resources</div></a>
        <a href="https://piazza.com/class/jkx2gta66436jq"><div class="navitem">Piazza</div></a>
    </div></div>
    <div id="sidebar">
        <div id="sidebar-content">
            <h3>Navigation</h3>
            <ul>
  <li><a href="index.html#due-monday-4-may-2020">Due Monday, 4 May 2020</a></li>
  <li><a href="index.html#a-overview-of-gitlet">A. Overview of Gitlet</a></li>
  <li><a href="index.html#b-internal-structures">B. Internal Structures</a></li>
  <li><a href="index.html#c-detailed-spec-of-behavior">C. Detailed Spec of Behavior</a></li>
  <ul>
    <li><a href="index.html#overall-spec">Overall Spec</a></li>
  </ul>
  <li><a href="index.html#d-the-commands">D. The Commands</a></li>
  <ul>
    <li><a href="index.html#init">init</a></li>
    <li><a href="index.html#add">add</a></li>
    <li><a href="index.html#commit">commit</a></li>
    <li><a href="index.html#rm">rm</a></li>
    <li><a href="index.html#log">log</a></li>
    <li><a href="index.html#global-log">global-log</a></li>
    <li><a href="index.html#find">find</a></li>
    <li><a href="index.html#status">status</a></li>
    <li><a href="index.html#checkout">checkout</a></li>
    <li><a href="index.html#branch">branch</a></li>
    <li><a href="index.html#rm-branch">rm-branch</a></li>
    <li><a href="index.html#reset">reset</a></li>
    <li><a href="index.html#merge">merge</a></li>
  </ul>
  <li><a href="index.html#e-miscellaneous-things-to-know-about-the-project">E. Miscellaneous Things to Know about the Project</a></li>
  <li><a href="index.html#dealing-with-files">Dealing with Files</a></li>
  <li><a href="index.html#serialization-details">Serialization Details</a></li>
  <li><a href="index.html#f-testing">F. Testing</a></li>
  <li><a href="index.html#g-design-document-and-checkpoint">G. Design Document and Checkpoint</a></li>
  <li><a href="index.html#h-going-remote-extra-credit">H. Going Remote (Extra Credit)</a></li>
  <li><a href="index.html#the-commands">The Commands</a></li>
  <ul>
    <li><a href="index.html#add-remote">add-remote</a></li>
    <li><a href="index.html#rm-remote">rm-remote</a></li>
    <li><a href="index.html#push">push</a></li>
    <li><a href="index.html#fetch">fetch</a></li>
    <li><a href="index.html#pull">pull</a></li>
  </ul>
  <li><a href="index.html#i-things-to-avoid">I. Things to Avoid</a></li>
  <li><a href="index.html#j-acknowledgments">J. Acknowledgments</a></li>
</ul>
        </div>
    </div>
    <div id="content-container"><main id="content">
        <header class="title">Project 3: Gitlet, your own version-control system</header>
        
<script type="text/x-mathjax-config">
	  MathJax.Hub.Config({
	    tex2jax: {inlineMath: [["$","$"]]}
	  });
	</script>
	<script type="text/javascript"
	   src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
	</script>


<h2 id="due-monday-4-may-2020">Due Monday, 4 May 2020</h2>


<p>[Revisions to the project spec since its release are <span class="updated">marked like this</span>.]</p>


<h2 id="a-overview-of-gitlet">A. Overview of Gitlet</h2>


<p>In this project you'll be implementing a version-control system that
mimics some of the basic features of the
popular system <a href="http://git-scm.com/">Git</a>.  Ours is
smaller and simpler, however, so we have named it Gitlet.</p>

<p>A version-control system is essentially a backup system for related collections
of files. The main functionality that Gitlet supports is:</p>

<ol>
  <li>Saving the contents of entire directories of files.
  In Gitlet, this is called <em>committing</em>, and the saved contents themselves are
  called <em>commits</em>.</li>
  <li>Restoring a version of one or more files or entire commits.
  In Gitlet, this is called <em>checking out</em> those files or that commit.</li>
  <li>Viewing the history of your backups. In Gitlet, you view this
  history in something called the <em>log</em>.</li>
  <li>Maintaining related sequences of commits, called <em>branches</em>.</li>
  <li>Merging changes made in one branch into another.</li>
</ol>

<p>The point of a version-control system is to help you when creating
complicated (or even not-so-complicated) projects, or when collaborating
with others on a project.
You save versions of the project periodically.
If at some later point in time you
accidentally mess up your code, then you can restore your source to
a previously committed version (without losing any of the changes
you made since then).  If your collaborators make changes embodied in a commit,
you can incorporate (<em>merge</em>) these changes into your own version.</p>

<p>In Gitlet, you don't just commit individual files at a time. Instead,
you can commit a coherent set of files at the same time. We like to think of
each commit as a <em>snapshot</em> of your entire project at one point
in time. However, for simplicity, many of the examples in the
remainder of this document involve changes to just one file at a time.
Just keep in mind you could change multiple files in each commit.</p>

<p>In this project, it will be helpful for us to visualize the commits we
make over time. Suppose we have a project consisting just of the
file wug.txt, we add some text to
it, and commit it. Then we modify the file and commit these changes.
Then we modify the file again, and commit the changes again. Now we
have saved three total versions of this file, each one later
in time than the previous. We can visualize these commits like so:</p>

<p><img src="image/three_commits.png" alt="Three commits"></p>

<p>Here we've drawn an arrow indicating that each commit contains some
kind of reference to the commit that came before it. We call the
commit that came before it the <em>parent commit</em>&mdash;this will be important
later. But for now, does this drawing look familiar? That's right;
it's a linked list!</p>

<p>The big idea behind Gitlet is that we can visualize the history of the
different versions of our files in a list like this. Then it's easy
for us to restore old versions of files. You can imagine making a
command like: "Gitlet, please revert to the state of the files at
commit #2", and it would go to the second node in the linked list and
restore the copies of files found there, while removing any files that are in the
first node, but not the second.</p>

<p>If we tell Gitlet to revert to an old commit, the front of the linked
list will no longer reflect the current state of your files, which
might be a little misleading. In order to fix this problem, we
introduce something called the <em>head</em> pointer. The head pointer keeps
track of where in the linked list we currently are. Normally, as
we make commits, the head pointer will stay at the front of the linked
list, indicating that the latest commit reflects the current state of
the files:</p>

<p><img src="image/simple_head.png" alt="Simple head"></p>

<p>However, let's say we revert to the state of the files at commit #2
(technically, this is the <em>reset</em> command, which you'll see later in
the spec). We move the head pointer back to show this:</p>

<p><img src="image/reverted_head.png" alt="Reverted head"></p>

<p>All right, now, if this were all Gitlet could do, it would be a pretty
simple system. But Gitlet has one more trick up its sleeve: it doesn't
just maintain older and newer versions of files, it can maintain
<em>differing</em> versions. Imagine you're coding a project, and you have
two ideas about how to proceed: let's call one Plan A, and the other
Plan B. Gitlet allows you to save both versions, and switch between
them at will. Here's what this might look like, in our pictures:</p>

<p><img src="image/two_versions.png" alt="Two versions"></p>

<p>It's not really a linked list anymore. It's more like a tree. We'll
call this thing the <em>commit tree</em>. Keeping with this metaphor, each of
the separate versions is called a <em>branch</em> of the tree. You can
develop each version separately:</p>

<p><img src="image/two_developed_versions.png" alt="Two developed versions"></p>

<p>There are two pointers into the tree, representing the furthest
point of each branch. At any given time, only one of these is the
currently active pointer, and this is what's called the head pointer. The
head pointer is the pointer at the front of the current branch.</p>

<p>That's it for our brief overview of the Gitlet system! Don't worry if
you don't fully understand it yet; the section above was just to give
you a high level picture of what its meant to do. A detailed spec of
what you're supposed to do for this project follows this section.</p>

<p>But a last word here: commit trees are
<em>immutable</em>: once a commit node has been created, it can
never be destroyed (or changed at all). We can only add new things to
the commit tree, not modify existing things. This is an important
feature of Gitlet! One of Gitlet's
goals is to allow us to save things so we don't delete
them accidentally.</p>


<h2 id="b-internal-structures">B. Internal Structures</h2>


<p>Real Git distinguishes several different kinds of <em>objects</em>.  For
our purposes, the important ones are</p>

<ul>
  <li><strong><em>blobs</em></strong>: Essentially the contents of files.</li>
  <li><strong><em>trees</em></strong>: Directory structures mapping names to references to blobs and
  other trees (subdirectories).</li>
  <li><strong><em>commits</em></strong>: Combinations of log messages,
  other metadata (commit date, author,
  etc.), a reference to a tree, and references to
  parent commits.
  The repository also maintains a mapping from <em>branch heads</em> (in this course,
  we've used names
  like  <code>master</code>, <code>proj2</code>, etc.) to references to commits, so that
  certain important commits have symbolic names.</li>
</ul>

<p>We will simplify from Git still
further by</p>

<ul>
  <li>Incorporating trees into commits and not dealing with subdirectories (so
  there will be one
  "flat" directory of plain files for each repository).</li>
  <li>Limiting ourselves to merges that reference two parents (in real Git, there
  can be any number of parents.)</li>
  <li>Having our metadata consist only of a timestamp and log message.
  A commit, therefore, will consist of a log message,
  timestamp, a mapping of file names to blob references, a parent
  reference, and (for merges) a second parent reference.</li>
</ul>

<p>Every object&mdash;every blob and every commit in our case&mdash;has a unique
integer id that serves as a reference to the object.
An interesting feature of Git is that these ids are <em>universal</em>:  unlike a
typical Java implementation, two objects with exactly the same content will
have the same id on all systems.  In the case of blobs, "same content" means
the same file contents.  In the case of commits, it means the same metadata,
the same mapping of names to references, and the same parent reference.
The objects in a repository are thus said to be <em>content addressable</em>.</p>

<p>Both Git and Gitlet accomplish this the same way: by using a <em>cryptographic
hash function</em> called SHA-1 (Secure Hash 1), which produces a 160-bit integer
hash from any sequence of bytes. Cryptographic hash functions have the property
that it is extremely difficult to find two different byte streams with the
same hash value (or indeed to find <em>any</em> byte stream given just its hash value),
so that essentially, we may assume that the probability
that any two objects with different contents have the same SHA-1 hash value is
2<sup>-160</sup> or about 10<sup>-48</sup>.  Basically, we simply ignore the
possibility of a hashing collision, so that the system has, in principle,
a fundamental bug that in practice never occurs!</p>

<p>Fortunately, there are library classes for computing SHA-1 values, so you won't
have to deal with the actual algorithm.
All you have to do is to make sure that you
correctly label all your objects.  In particular, this involves</p>

<ul>
  <li>Including all metadata and references when hashing a commit.</li>
  <li>Distinguishing somehow between hashes for commits and hashes for blobs.  A
  good way to do so is to hash in an extra word for each object that
  has one value for blobs and another for commits.</li>
</ul>

<p>By the way, the SHA-1 hash value, rendered as a 40-character
hexadecimal string, makes
a convenient file name for storing your data in your <code>.gitlet</code>
directory (more on that below).  It also gives you a convenient way to
compare two files (blobs) to see if they have the same contents: if their
SHA-1s are the same, we simply assume the files are the same.</p>

<p>For remotes (like <code>origin</code> and <code>shared</code>, which we've been using all semester),
we'll simply use other Gitlet repositories.  Pushing simply means copying all
commits and blobs that the remote repository does not yet have to the remote
repository, and resetting a branch reference.  Pulling is the same, but in the
other direction</p>

<p>Reading and writing your internal objects from and to files is actually pretty
easy, thanks to Java's <em>serialization</em> facilities.  The interface
<code>java.io.Serializable</code> has no methods,
but if a class implements it, then the Java
runtime will automatically provide a way to convert to and from a stream of
bytes, which you can then write to a file using the I/O class
<code>java.io.ObjectOutputStream</code> and read back (and deserialize) with
<code>java.io.ObjectInputStream</code>.
The term "serialization" refers to the conversion from some arbitrary structure
(array, tree, graph, etc.) to a serial sequence of bytes.</p>

<p>Here is a summary example of the structures discussed in this section.
As you can see, each commit (rectangle) points to some blobs (circles), which
contain file contents.  The commits contain the file names and references to
these blobs, as well as a parent link.  These references, depicted as arrows,
are represented in the <code>.gitlet</code> directory using their SHA-1 hash values (the
small hexadecimal numerals above the commits and below the blobs).  The newer
commit contains an updated version of <code>wug1.txt</code>, but shares the same version
of <code>wug2.txt</code> as the older commit.</p>

<p><img src="image/commits-and-blobs.png" alt="Two commits and their blobs"></p>


<h2 id="c-detailed-spec-of-behavior">C. Detailed Spec of Behavior</h2>



<h4 id="overall-spec">Overall Spec</h4>


<p>The only structure requirement we're giving you is that you have a
class named <code>gitlet.Main</code> and that it has a main method. Here's your skeleton
code for this project (in package Gitlet):</p>

<pre><code>public class Main {
    public static void main(String[] args) {
       // FILL IN
    }
}</code></pre>

<p>We are also giving you some utility methods for performing a number of
mostly file-system-related tasks, so that you can concentrate on the logic
of the project rather than the peculiarities of dealing with the OS.</p>

<p>You may, of course, write additional Java classes to support your
project&mdash;in fact, please do. But don't use any external code (aside
from JUnit), and don't use any programming language other than Java.
You can use all of the Java Standard Library that you wish, plus utilities we
provide.</p>

<p>The majority of this spec will describe how <code>Gitlet.java</code>'s main
method must react when it receives various gitlet commands as
command-line arguments. But before we break down command-by-command,
here are some overall guidelines the whole project should
satisfy:</p>

<ul>
  <li>In order for Gitlet to work, it will need a place to store old
  copies of files and other
  metadata. All of this stuff <strong>must</strong> be stored in a directory called
  <code>.gitlet</code>, just as this information is stored in directory <code>.git</code> for the
  real git system (files with a <code>.</code> in front are hidden files. You will
  not be able to see them by default on most operating systems.  On Unix,
  the command <code>ls &#x2d;a</code> will show them.) A
  Gitlet system is considered "initialized" in a particular location if
  it has a <code>.gitlet</code> directory there. Most Gitlet commands (except for the
  <code>init</code>  command) only need to work when used from a directory where a
  Gitlet system has been initialized&mdash;i.e. a directory that has a
  <code>.gitlet</code> directory. The files that <em>aren't</em> in your <code>.gitlet</code>
  directory (which are copies of files from the repository that you are
  using and editing, as well as files you plan to add to the repository) are
  referred to as the files in your <em>working directory</em>.</li>
  <li>Most commands have runtime or memory usage requirements. You must
  follow these. Some of the runtimes are described as constant
  "relative to any significant measure". The significant measures are:
  any measure of number or size of files, any measure of number of
  commits. You can ignore time required to serialize or deserialize,
  <em>with the one caveat that your serialization time cannot depend in
  any way on the total size of files that have been added, committed,
  etc</em> (what is serialization? You'll see later in the spec). You can
  also pretend that getting from a hash table is constant time.</li>
  <li>Some commands have failure cases with a specified error message. The
  exact formats of these are specified later in the spec. All error
  message end with a period; since our autograding is literal, be
  sure to include it. If your
  program ever encounters one of these failure cases, it must print
  the error message and not change anything else. <em>You don't need to
  handle any other error cases except the ones listed as failure
  cases</em>.</li>
  <li><p>There are some failure cases you need to handle that don't apply to
  a particular command. Here they are:</p>

  <ul>
    <li>If a user doesn't input any arguments, print the message
    <code>Please enter a command.</code> and exit.</li>
    <li>If a user inputs a command that doesn't exist, print the
    message <code>No command with that name exists.</code> and exit.</li>
    <li>If a user inputs a command with the wrong number or format of
    operands, print the message <code>Incorrect operands.</code> and exit.</li>
    <li>If a user inputs a command that requires being in an initialized
    Gitlet working directory (i.e., one containing a <code>.gitlet</code> subdirectory),
    but is not in such a directory, print the message <code>Not in an initialized
    Gitlet directory.</code></li>
  </ul></li>
  <li>Some of the commands have their differences from real Git
  listed. The spec is not exhaustive in listing <em>all</em> differences from
  git, but it does list some of the bigger or potentially confusing
  and misleading ones.</li>
  <li>Do <strong>NOT</strong> print out anything except for what the spec says. Some of
  our autograder tests will break if you print anything more than
  necessary.</li>
  <li>Always exit with exit code 0, even in the presence of errors.  This allows
  us to use other exit codes as an indication that something blew up.</li>
  <li>The spec classifies some commands as "dangerous". Dangerous commands
  are ones that potentially overwrite files (that aren't just
  metadata)&mdash;for example, if a user tells Gitlet to restore files to
  older versions, Gitlet may overwrite the current versions of the
  files. Just FYI.</li>
</ul>


<h2 id="d-the-commands">D. The Commands</h2>



<h4 id="init">init</h4>


<ul>
  <li><strong>Usage</strong>: <code>java gitlet.Main init</code></li>
  <li><strong>Description</strong>: Creates a new Gitlet version-control system in the
  current directory. This system will automatically start with one
  commit: a commit that contains no files and has the commit message
  <code>initial commit</code> (just like that, with no punctuation).
  It will have a single branch: <code>master</code>, which
  initially points to this initial commit, and <code>master</code> will be the
  current branch.  The timestamp for this initial commit will be
  00:00:00 UTC, Thursday, 1 January 1970 in whatever format you
  choose for dates (this is
  called "The (Unix) Epoch", represented internally by the time 0.)
  Since the initial commit in all repositories
  created by Gitlet will have exactly the same content,
  it follows that all repositories will automatically share
  this commit (they will all have the same UID)
  and all commits in all repositories will trace back to it.</li>
  <li><strong>Runtime</strong>: Should be constant relative to any significant measure.</li>
  <li><strong>Failure cases</strong>: If there is already a Gitlet version-control
  system in the current directory, it should abort. It should NOT
  overwrite the existing system with a new one. Should print the error
  message <code>A Gitlet version&#x2d;control system already exists in the
  current directory.</code></li>
  <li><strong>Dangerous?</strong>: No</li>
  <li><strong>Our line count</strong>: ~25</li>
</ul>


<h4 id="add">add</h4>


<ul>
  <li><strong>Usage</strong>: <code>java gitlet.Main add [file name]</code></li>
  <li><strong>Description</strong>: Adds a copy of the file as it currently exists to
  the <em>staging area</em> (see the description of the <code>commit</code>
  command).  For this reason, adding a file is also
  called <em>staging</em> the file <em>for addition</em>.
  Staging an already-staged file overwrites the previous entry
  in the staging area with the new contents.
  The staging area should be somewhere in
  <code>.gitlet</code>. If the current working version of the file is identical to
  the version in the current commit, do not stage it to be added,
  and remove it from the staging area if it is already there (as
  can happen when a file is changed, added, and then changed back).
  The file will no longer be staged for removal (see <code>gitlet rm</code>), if it
  was at the time of the command.</li>
  <li><strong>Runtime</strong>: In the worst case, should run in linear time relative
  to the size of the file being added <span class="updated">and $\lg N$, for $N$ the
  number of files in the commit.</span></li>
  <li><strong>Failure cases</strong>: If the file does not exist, print the error
  message <code>File does not exist.</code> and exit without changing
  anything.</li>
  <li><strong>Dangerous?</strong>: No</li>
  <li><strong>Our line count</strong>: ~20</li>
</ul>


<h4 id="commit">commit</h4>


<ul>
  <li><strong>Usage</strong>: <code>java gitlet.Main commit [message]</code></li>
  <li><p><strong>Description</strong>: Saves a snapshot of certain files in the current commit
  and staging area so they can be
  restored at a later time, creating a new commit.
  The commit is said to be <em>tracking</em> the saved files. By default,
  each commit's snapshot of files will be exactly the same as its
  parent commit's snapshot of files; it will keep versions of files
  exactly as they are, and not update them. A commit will only update
  the contents of files it is tracking that have been staged
  for addition at
  the time of commit, in which case the commit will now include the
  version of the file that was staged instead of the version it got
  from its parent. A commit will save and start tracking any files
  that were staged for addition but weren't tracked by its parent.  Finally, files tracked
  in the current commit may be untracked in the new commit as a result
  being <em>staged for removal</em> by the
  <code>rm</code> command (below).</p>

  <p>The bottom line: By default a commit is the same as its parent.
  Files staged for addition and removal are the updates to the commit.</p>

  <p>Some additional points about commit:</p>

  <ul>
    <li>The staging area is cleared after a commit.</li>
    <li>The commit command never adds, changes, or removes files in the
    working directory (other than those in the <code>.gitlet</code> directory).  The
    <code>rm</code> command <em>will</em> remove such files, as well as staging them for
    removal, so that they will be untracked after a <code>commit</code>.</li>
    <li>Any changes made to files after staging for addition or removal
    are ignored by the
    <code>commit</code> command, which <em>only</em> modifies the contents of the <code>.gitlet</code>
    directory.  For example, if you remove a tracked file using the Unix
    <code>rm</code> command (rather than Gitlet's command of the same name), it has
    no effect on the next commit, which will still contain the deleted version
    of the file.</li>
    <li>After the commit command, the new commit is added as a new node
    in the commit tree.</li>
    <li>The commit just made becomes the "current commit", and the head
    pointer now points to it. The previous head commit is this
    commit's parent commit.</li>
    <li>Each commit should contain the date and time it was made.</li>
    <li>Each commit has a log message associated with it that describes the
    changes to the files in the commit. This is specified by the
    user. The entire message should take up only one entry in
    the array <code>args</code> that is passed to <code>main</code>. To include multiword
    messages, you'll have to surround them in quotes.</li>
    <li>Each commit is identified by its SHA-1 id, which must include the
    file (blob) references of its files,
    parent reference, log message, and commit time.</li>
  </ul></li>
  <li><strong>Runtime</strong>: Runtime should be constant with respect to any measure
  of number of commits. Runtime must be no worse than linear with
  respect to the total size of files the commit is tracking.
  Additionally, this command has a memory requirement: Committing must
  increase the size of the <code>.gitlet</code> directory by no more than the total
  size of the files staged for addition at the time of commit, not including
  additional metadata. This means don't store redundant copies of
  versions of files that a commit receives from its parent.
  You <em>are</em> allowed to save whole additional copies of files;
  don't worry about only saving diffs, or anything like that.</li>
  <li><strong>Failure cases</strong>: If no files have been staged, abort. Print the message <code>No
  changes added to the commit.</code> Every commit must have a non-blank
  message. If it doesn't, print the error message <code>Please enter
  a commit message.</code> It is <em>not</em> a failure for tracked files to be
  missing from the working directory or changed in the working directory.
  Just ignore everything outside the <code>.gitlet</code> directory entirely.</li>
  <li><strong>Dangerous?</strong>: No</li>
  <li><strong>Differences from real git</strong>: In real git, commits may have multiple
  parents (due to merging) and also have considerably more metadata.</li>
  <li><strong>Our line count</strong>: ~35</li>
</ul>

<p>Here's a picture of before-and-after commit:</p>

<p><img src="image/before_and_after_commit.png" alt="Before and after commit"></p>


<h4 id="rm">rm</h4>


<ul>
  <li><strong>Usage</strong>: <code>java gitlet.Main rm [file name]</code></li>
  <li><strong>Description</strong>: Unstage the file if it is currently staged for addition.
  If the file is tracked in the current commit, stage it for removal and
  remove the file from the working directory if the user has not already
  done so (do <em>not</em> remove it unless
  it is tracked in the current commit).</li>
  <li><strong>Runtime</strong>: Should run in constant time relative to any significant measure.</li>
  <li><strong>Failure cases</strong>: If the file is neither staged nor tracked by the
  head commit, print the error message <code>No reason to remove the file.</code></li>
  <li><strong>Dangerous?</strong>: Yes (although if you use our utility methods, you will only
  hurt your repository files, and not all the other files in your
  directory.)</li>
  <li><strong>Our line count</strong>: ~20</li>
</ul>


<h4 id="log">log</h4>


<ul>
  <li><strong>Usage</strong>: <code>java gitlet.Main log</code></li>
  <li><p><strong>Description</strong>: Starting at the current head commit, display
  information about each commit backwards along the commit tree until
  the initial commit, following the first parent commit links, ignoring any
  second parents found in merge commits.  (In regular Git, this is what
  you get with <code>git log &#x2d;&#x2d;first&#x2d;parent</code>).
  This set of commit nodes is called the commit's
  <em>history</em>. For every node in this history, the information it should
  display is the commit id, the time the commit was made, and the
  commit message. Here is an example of the <em>exact</em> format it should
  follow:</p>

<pre><code>   ===
   commit a0da1ea5a15ab613bf9961fd86f010cf74c7ee48
   Date: Thu Nov 9 20:00:05 2017 &#x2d;0800
   A commit message.

   ===
   commit 3e8bf1d794ca2e9ef8a4007275acf3751c7170ff
   Date: Thu Nov 9 17:01:33 2017 &#x2d;0800
   Another commit message.

   ===
   commit e881c9575d180a215d1a636545b8fd9abfb1d2bb
   Date: Wed Dec 31 16:00:00 1969 &#x2d;0800
   initial commit</code></pre>

  <p>There is a <code>===</code> before each commit and an empty line after it.
  As in real Git, each entry displays the unique SHA-1 id of the commit
  object. The timestamps displayed in the commits reflect
  the current timezone, not UTC; as a result, the timestamp for the initial
  commit does not read Thursday, January 1st, 1970, 00:00:00, but rather the
  equivalent Pacific Standard Time.
  Display commits with the most recent at the top. By the way, you'll find
  that the Java classes <code>java.util.Date</code> and <code>java.util.Formatter</code>
  are useful for getting and formatting times.
  Look into them instead of trying to construct
  it manually yourself!</p>

  <p>For merge commits (those that have two parent commits),
  add a line just below the first, as in</p>

<pre><code>   ===
   commit 3e8bf1d794ca2e9ef8a4007275acf3751c7170ff
   Merge: 4975af1 2c1ead1
   Date: Sat Nov 11 12:30:00 2017 &#x2d;0800
   Merged development into master.</code></pre>

  <p>where the two hexadecimal numerals following "Merge:" consist of the first seven
  digits of the first and second parents' commit ids, in that order.  The first
  parent is the branch you were on when you did the merge; the second is that of
  the merged-in branch. This is as in regular Git.</p></li>
  <li><strong>Runtime</strong>: Should be linear with respect to the number of nodes in
  head's history.</li>
  <li><strong>Failure cases</strong>: None</li>
  <li><strong>Dangerous?</strong>: No</li>
  <li><strong>Our line count</strong>: ~20</li>
</ul>

<p>Here's a picture of the history of a particular commit. If the current
branch's head pointer happened to be pointing to that commit, log
would print out information about the circled commits:</p>

<p><img src="image/history.png" alt="History"></p>

<p>The history ignores other branches and the future. Now that we have
the concept of history, let's refine what we said earlier about the
commit tree being immutable. It is immutable precisely in the sense
that <em>the history of a commit with a particular id may never change,
ever</em>. If you think of the commit tree as nothing more than a
collection of histories, then what we're really saying is that each
history is immutable.</p>


<h4 id="global-log">global-log</h4>


<ul>
  <li><strong>Usage</strong>: <code>java gitlet.Main global&#x2d;log</code></li>
  <li><strong>Description</strong>: Like log, except displays information about all
  commits ever made. The order of the commits does not matter.</li>
  <li><strong>Runtime</strong>: Linear with respect to the number of commits ever made.</li>
  <li><strong>Failure cases</strong>: None</li>
  <li><strong>Dangerous?</strong>: No</li>
  <li><strong>Our line count</strong>: ~10</li>
</ul>


<h4 id="find">find</h4>


<ul>
  <li><strong>Usage</strong>: <code>java gitlet.Main find [commit message]</code></li>
  <li><strong>Description</strong>: Prints out the ids of all commits that have the given
  commit message, one per line.
  If there are multiple such commits, it prints the
  ids out on separate lines.  The commit message is a single operand; to
  indicate a multiword message, put the operand in quotation marks, as for
  the <code>commit</code> command below.</li>
  <li><strong>Runtime</strong>: Should be linear relative to the number of commits.</li>
  <li><strong>Failure cases</strong>: If no such commit exists, prints the error
  message <code>Found no commit with that message.</code></li>
  <li><strong>Dangerous?</strong>: No</li>
  <li><strong>Differences from real git</strong>: Doesn't exist in real git. Similar
  effects can be achieved by grepping the output of log.</li>
  <li><strong>Our line count</strong>: ~15</li>
</ul>


<h4 id="status">status</h4>


<ul>
  <li><strong>Usage</strong>: <code>java gitlet.Main status</code></li>
  <li><p><strong>Description</strong>: Displays what branches currently exist, and marks
  the current branch with a <code>*</code>. Also displays what files have been
  staged for addition or removal. An example of the <em>exact</em> format it
  should follow is as follows.</p>

<pre><code>=== Branches ===
*master
other&#x2d;branch

=== Staged Files ===
wug.txt
wug2.txt

=== Removed Files ===
goodbye.txt

=== Modifications Not Staged For Commit ===
junk.txt (deleted)
wug3.txt (modified)

=== Untracked Files ===
random.stuff</code></pre>

  <p>There is an empty line between sections. Entries should be listed in
  lexicographic order, using the Java string-comparison order (the asterisk
  doesn't count).  A file in the working directory
  is "modified but not staged" if it is</p></li>
  <li>Tracked in the current commit, changed in the working directory,
  but not staged; or</li>
  <li>Staged for addition, but with different contents than in the working
  directory; or</li>
  <li>Staged for addition, but deleted in the working directory; or</li>
  <li><p>Not staged for removal, but tracked in the current commit and deleted from
  the working directory.</p>

  <p>The final category ("Untracked Files") is for files present in the working
  directory but neither staged for addition nor tracked.  This includes files
  that have been staged for removal, but then <span class="updated">re-created</span> without Gitlet's
  knowledge. Ignore any subdirectories
  that may have been
  introduced, since Gitlet does not deal with them.</p>

  <p>The last two sections (modifications not staged and untracked files) are
  extra credit, worth 1 point.  Feel free to leave them blank (leaving just the headers).</p></li>
  <li><strong>Runtime</strong>: Make sure this depends only on the amount of data in the
  working directory plus the number of files staged to be added or deleted
  plus the number of branches.</li>
  <li><strong>Failure cases</strong>: None</li>
  <li><strong>Dangerous?</strong>: No</li>
  <li><strong>Our line count</strong>: ~45</li>
</ul>


<h4 id="checkout">checkout</h4>


<p>Checkout is a kind of general command that can do a few different
things depending on what its arguments are. There are 3 possible use
cases. In each section below, you'll see 3 bullet points. Each
corresponds to the respective usage of checkout.</p>

<ul>
  <li><p><strong>Usages</strong>:</p>

  <ol>
    <li><code>java gitlet.Main checkout &#x2d;&#x2d; [file name]</code></li>
    <li><code>java gitlet.Main checkout [commit id] &#x2d;&#x2d; [file name]</code></li>
    <li><code>java gitlet.Main checkout [branch name]</code></li>
  </ol></li>
  <li><p><strong>Descriptions</strong>:</p>

  <ol>
    <li>Takes the version of the file as it exists in the head commit,
    the front of the current branch, and puts it in the working directory,
    overwriting the version of the file that's already there if there is
    one.  The new version of the file is not staged.</li>
    <li>Takes the version of the file as it exists in the commit with
    the given id, and puts it in the working directory, overwriting
    the version of the file that's already there if there is one.
    The new version of the file is not staged.</li>
    <li>Takes all files in the commit at the head of the given branch,
    and puts them in the working directory, overwriting the versions
    of the files that are already there if they exist. Also, at the
    end of this command, the given branch will now be considered the
    current branch (HEAD).  Any files that are tracked in the current
    branch but are not present in the checked-out branch are deleted.
    The staging area is cleared, unless the checked-out branch is the
    current branch (see <strong>Failure cases</strong> below).</li>
  </ol></li>
  <li><p><strong>Runtimes</strong>:</p>

  <ol>
    <li>Should be linear relative to the size of the file being checked out.</li>
    <li>Should be linear with respect to the total size of the files in
    the commit's snapshot. Should be constant with respect to any
    measure involving number of commits. Should be constant with
    respect to the number of branches.</li>
  </ol></li>
  <li><p><strong>Failure cases</strong>:</p>

  <ol>
    <li>If the file does not exist in the previous commit, abort,
    printing the error message <code>File does not exist in that
    commit.</code></li>
    <li>If no commit with the given id exists, print <code>No commit with
    that id exists.</code> Otherwise, if the file does not exist in the given
    commit, print the same message as for failure case 1.</li>
    <li>If no branch with that name exists, print <code>No such branch exists.</code>
    If that branch is the current branch, print <code>No need to checkout the
    current branch.</code>  If a working file is untracked in the current
    branch and would be overwritten by the checkout, print
    <span class="updated"><code>There is an untracked file in the way; delete it, or add and commit it first.</code></span>
    and exit; perform this check before doing anything else.</li>
  </ol></li>
  <li><strong>Differences from real git</strong>: Real git does not clear the staging area
  and stages the file that is checked out.
  Also, it won't do a checkout that would overwrite or undo changes (additions
  or removals) that you have staged.</li>
</ul>

<p>A [commit id] is, as described earlier, a hexadecimal numeral.  A convenient
feature of real Git is that one can abbreviate commits with a unique
prefix.  For example, one might abbreviate</p>

<pre><code>a0da1ea5a15ab613bf9961fd86f010cf74c7ee48</code></pre>

<p>as</p>

<pre><code>a0da1e</code></pre>

<p>in the (likely) event that no other object exists with a SHA-1 identifier that
starts with the same six digits.  You should arrange for the same thing to
happen for commit ids that contain fewer than 40 characters.  Unfortunately,
using shortened ids might slow down the finding of objects if implemented
naively (making the time to find a file linear in the number of objects), so
we won't worry about timing for commands that use shortened ids.  We suggest,
however, that you poke around in a <code>.git</code> directory (specifically,
<code>.git/objects</code>) and see how it manages to speed up its search. You will perhaps
recognize a familiar data structure implemented with the file system rather
than pointers.</p>

<p>Only version 3 (checkout of a full branch) modifies the staging area:
otherwise files scheduled for
addition or removal remain so.</p>

<ul>
  <li><strong>Dangerous?</strong>: Yes!</li>
  <li><p><strong>Our line counts</strong>:</p>

  <ul>
    <li>~15</li>
    <li>~5</li>
    <li>~15</li>
  </ul></li>
</ul>


<h4 id="branch">branch</h4>


<ul>
  <li><strong>Usage</strong>: <code>java gitlet.Main branch [branch name]</code></li>
  <li><strong>Description</strong>: Creates a new branch with the given name, and
  points it at the current head node. A branch is nothing more than a
  name for a reference (a SHA-1 identifier)
  to a commit node. This command does NOT immediately switch to the newly
  created branch (just as in real Git).
  Before you
  ever call branch, your code should be running with a default branch
  called "master".</li>
  <li><strong>Runtime</strong>: Should be constant relative to any significant measure.</li>
  <li><strong>Failure cases</strong>: If a branch with the given name already exists,
  print the error message <code>A branch with that name already exists.</code></li>
  <li><strong>Dangerous?</strong>: No</li>
  <li><strong>Our line count</strong>: ~10</li>
</ul>

<p>All right, let's see what branch does in detail. Suppose our state
looks like this:</p>

<p><img src="image/simple_history.png" alt="Simple history"></p>

<p>Now we call <code>java gitlet.Main branch cool&#x2d;beans</code>. Then we get this:</p>

<p><img src="image/just_called_branch.png" alt="Just called branch"></p>

<p>Hmm... nothing much happened. Let's switch to the branch with <code>java
Gitlet checkout cool&#x2d;beans</code>:</p>

<p><img src="image/just_switched_branch.png" alt="Just switched branch"></p>

<p>Nothing much happened again?! Okay, say we make a commit now. Modify
some files, then <code>java gitlet.Main add...</code> then <code>java gitlet.Main commit...</code></p>

<p><img src="image/commit_on_branch.png" alt="Commit on branch"></p>

<p>I was told there would be branching. But all I see is a straight line.
What's going on? Maybe I should go back to my other branch with <code>java
Gitlet checkout master</code>:</p>

<p><img src="image/checkout_master.png" alt="Checkout master"></p>

<p>Now I make a commit...</p>

<p><img src="image/branched.png" alt="Branched"></p>

<p>Phew! So that's the whole idea of branching. Did you catch what's
going on? All that creating a branch does is to give us a new pointer. At any
given time, one of these pointers is considered the currently active
pointer, or the head pointer (indicated by *). We can switch the
currently active head pointer with <code>checkout [branch name]</code>. Whenever
we commit, it means we add a new commit in front of the currently
active head pointer, even if one is already there. This naturally
creates branching behavior.</p>

<p>Make <em>sure</em> that the behavior of your <code>branch</code>, <code>checkout</code>, and
<code>commit</code> match what we've described above. This is pretty core
functionality of Gitlet that many other commands will depend upon. If
any of this core functionality is broken, very many of our autograder
tests won't work!</p>


<h4 id="rm-branch">rm-branch</h4>


<ul>
  <li><strong>Usage</strong>: <code>java gitlet.Main rm&#x2d;branch [branch name]</code></li>
  <li><strong>Description</strong>: Deletes the branch with the given name. This only
  means to delete the pointer associated with the branch; it does not
  mean to delete all commits that were created under the branch, or
  anything like that.</li>
  <li><strong>Runtime</strong>: Should be constant relative to any significant measure.</li>
  <li><strong>Failure cases</strong>: If a branch with the given name does not exist,
  aborts. Print the error message <code>A branch with that name does not
  exist.</code> If you try to remove the branch you're currently on, aborts,
  printing the error message <code>Cannot remove the current branch.</code></li>
  <li><strong>Dangerous?</strong>: No</li>
  <li><strong>Our line count</strong>: ~15</li>
</ul>


<h4 id="reset">reset</h4>


<ul>
  <li><strong>Usage</strong>: <code>java gitlet.Main reset [commit id]</code></li>
  <li><strong>Description</strong>: Checks out all the files tracked by the given
  commit. Removes tracked files that are not present in that commit.
  Also moves the current branch's head to that commit node.
  See the intro for an example of what happens to the head pointer
  after using reset.  The <code>[commit id]</code> may be abbreviated as for
  <code>checkout</code>.  The staging area is cleared.  The command is essentially
  <code>checkout</code> of an arbitrary commit that also changes the current branch
  head.</li>
  <li><strong>Runtime</strong>: Should be linear with respect to the total size of
  files tracked by the given commit's snapshot. Should be constant
  with respect to any measure involving number of commits.</li>
  <li><strong>Failure case</strong>: If no commit with the given id exists, print <code>No
  commit with that id exists.</code>  If a working file is untracked in the current
  branch and would be overwritten by the reset, print
  <span class="updated"><code>There is an untracked file in the way; delete it, or add and commit it first.</code></span> and exit;
  perform this check before doing anything else.</li>
  <li><strong>Dangerous?</strong>: Yes!</li>
  <li><strong>Differences from real git</strong>: This command is
  closest to using the <code>&#x2d;&#x2d;hard</code> option, as in <code>git reset &#x2d;&#x2d;hard [commit
  hash]</code>.</li>
  <li><strong>Our line count</strong>: ~10</li>
</ul>


<h4 id="merge">merge</h4>


<ul>
  <li><strong>Usage</strong>: <code>java gitlet.Main merge [branch name]</code></li>
  <li><p><strong>Description</strong>: Merges files from the given branch into the current
  branch. This method is a bit complicated, so here's a more detailed
  description:</p>

  <ul>
    <li><p>First consider what might be called the <em>split point</em> of the
    current branch and the given branch.
    For example, if <code>master</code> is the current branch and <code>branch</code> is the given
    branch:
    <img src="image/split_point.png" alt="Split point">
    The split point is a <em>latest common ancestor</em> of the current and given
    branch heads:</p>

    <ul>
      <li>A <em>common ancestor</em> is a commit to which there is a path
      (of 0 or more parent pointers) from both branch heads.</li>
      <li>A <em>latest</em> common ancestor is a common ancestor that is not an
      ancestor of any other common ancestor.
      For example, although the leftmost commit in the diagram above is a
      common ancestor of <code>master</code> and <code>branch</code>, it is also an ancestor of the
      commit immediately to its right, so it is not a latest common
      ancestor.
      If the split point <em>is</em> the same commit as the given branch, then
      we do nothing; the merge is complete, and the operation ends with the
      message <code>Given branch is an ancestor of the current branch.</code>
      If the split point is the current branch, then the effect is to
      check out the given branch, and the operation
      ends after printing the message <code>Current branch fast&#x2d;forwarded.</code>
      Otherwise, we continue
      with the steps below.</li>
    </ul></li>
    <li>Any files that have been <em>modified</em> in the given branch since
    the split point, but not modified in the current branch since
    the split point should be changed to their versions in the given
    branch (checked out from the commit at the front of the given
    branch). These files should then all be automatically staged.
    To clarify, if a file is "modified in the given branch since the
    split point" this means the version of the file as it exists in
    the commit at the front of the given branch has different
    content from the version of the file at the split point.</li>
    <li>Any files that have been modified in the current branch but not
    in the given branch since the split point should stay as they
    are.</li>
    <li>Any files that have been modified in both the current and
    given branch in the same way (i.e., both to files with the same
    content or both removed) are left unchanged by the merge.
    If a file is removed in both, but a file of that name is present in
    the working directory
    that file is not removed from the working directory (but it continues
    to be absent&mdash;not staged&mdash;in the merge).</li>
    <li>Any files that were not present at the split point and are
    present only in the current branch should remain as they are.</li>
    <li>Any files that were not present at the split point and are
    present only in the given branch should be checked out and
    staged.</li>
    <li>Any files present at the split point, unmodified in the current
    branch, and absent in the given branch should be removed (and untracked).</li>
    <li>Any files present at the split point, unmodified in the given branch,
    and absent in the current branch should remain absent.</li>
    <li><p>Any files modified in different ways
    in the current and given branches are <em>in conflict</em>.  "Modified in
    different ways" can mean that the contents of both are changed and
    different from other, or the contents of one are changed and the other
    file is deleted, or the file was absent at the split point
    and has different
    contents in the given and current branches.  In this case, replace
    the contents of the conflicted file with</p>

<pre><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
contents of file in current branch
=======
contents of file in given branch
&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code></pre>

    <p>(replacing "contents of..." with the indicated file's contents)
    and stage the result.
    Treat a deleted file in a branch
    as an empty file.  Use straight concatenation here.  In the case
    of a file with no newline at the end, you might well end up with
    something like this:</p>

<pre><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
contents of file in current branch=======
contents of file in given branch&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code></pre>

    <p>This is fine; people who produce non-standard, pathological files
    because they don't know the difference between a line terminator
    and a line separator deserve what they get.</p></li>
    <li>Once files have been updated according to the above, and the split
    point was not the current branch or the given branch,
    merge automatically commits with the log message
    <code>Merged [given branch name] into [current branch name].</code>
    Then, if the merge
    encountered a conflict,
    print the message <code>Encountered a merge conflict.</code> on the terminal (not
    the log).
    Merge commits differ from other commits: they record as parents
    both the head of the current branch (called the <em>first parent</em>)
    and the head of the branch given on the command line to be merged in.</li>
    <li><p>There is one complication in the definition of the split point.  You
    may have noticed that we referred to "a", rather than "the"
    latest common ancestor. This is because there can be more than one in
    the case of "criss-cross merges", such as this:
    <img src="image/crisscross2.png" alt="Criss-Cross Merge">
    Here, the solid lines are first parents and the dashed lines are the
    merged-in parents.  Both the commits pointed by blue arrows above are
    latest common ancestors.
    <br/>
    			<span class="updated">Here's how this was created:
    			Branch splits from master in the left most commit. We make initial commits in branch and in master. We then create a new branch temp, splitting from branch.
    			Then we merge master into branch, creating the second bottom commit from the right. This also moves the head of branch forward. We make another commit in master, and then merge temp into master. Then, we make another commit in master and branch. Now if we want to merge branch into master, we have two possible split points: the commits marked by the two blue arrows. </span>
    			You might want to think about why it can
    make a difference which gets used as the split point.  We'll use the
    following rule to choose which of multiple possible split points to
    use:</p>

    <ul>
      <li>Choose the candidate split point that is closest to the
      head of the current branch (that is, is reachable by following
      the fewest parent pointers along some path).</li>
      <li>If multiple candidates are at the same closest distance, choose
      any one of them as the split point.  (We will make sure that this
      only happens in our test cases when the resulting merge commit
      is the same with any of the closest choices.)</li>
    </ul></li>
  </ul>

  <p>By the way, we hope you've noticed that the set of commits has progressed
  from a simple sequence to a tree and now, finally, to a full
  directed acyclic graph.</p></li>
  <li><strong>Runtime</strong>: $O(N\lg N + D)$, where $N$ is the total number
  of ancestor commits for the two branches and $D$ is the total amount of
  data in all the files under these commits.</li>
  <li><strong>Failure cases</strong>: If there are staged additions or removals present,
  print the error message <code>You have uncommitted changes.</code> and exit.
  If a branch with the given name does not exist,
  print the error message <code>A branch with that name does not exist.</code> If
  attempting to merge a branch with itself, print the error message
  <code>Cannot merge a branch with itself.</code> If merge would generate an
  error because the commit that it does has no changes in it, just let
  the normal commit error message for this go through.
  If an untracked file in the current commit would be overwritten or deleted by the merge, print
  <span class="updated"><code>There is an untracked file in the way; delete it, or add and commit it first.</code></span> and
  exit; perform this check before doing anything else.</li>
  <li><strong>Dangerous?</strong>: Yes!</li>
  <li><p><strong>Differences from real git</strong>:
  Real Git does a more subtle job of merging files, displaying conflicts only
  in places where both files have changed since the split point.</p>

  <p>Real Git has a different way to decide which of multiple possible split
  points to use.</p>

  <p>Real Git will force the user to resolve the merge
  conflicts before committing to complete the merge. Gitlet just
  commits the merge, conflicts and all, so that you must use a separate
  commit to resolve problems.</p>

  <p>Real Git will complain if there are unstaged changes to a file that
  would be changed by a merge.  You may do so as well if you want, but we
  will not test that case.</p></li>
  <li><strong>Our line count</strong>: ~70</li>
</ul>

<!--

#### rebase

<ul>
  <li><strong>Usage</strong>: <code>java gitlet.Main rebase [branch name]</code></li>
  <li><p><strong>Description</strong>: Conceptually, what rebase does is find the split
  point of the current branch and the given branch, then snaps off the
  current branch at this point, then reattaches the current branch to
  the head of the given branch. Say we are on branch <code>branch</code> and we
  make the call <code>java gitlet.Main rebase master</code>: <img src="image/conceptual_rebase.png" alt="Conceptual
  rebase"> Now, this may prompt two
  questions:</p>

  <ul>
    <li><em>Why would you ever want to do this?</em> You can think of it as an
    alternative to merge, where instead of having two branches that
    come together, you just pretend as if one of the branches came
    after the other one. If you use it smartly, this can create a
    cleaner history than merge.</li>
    <li><em>Doesn't this ruin what you said about the commit tree being
    immutable?</em> Yes, it does! That's because we just lied to you in
    the picture above. In fact, rebase does not break off the
    current branch. Instead, it leaves the current branch there, but
    makes a <em>copy</em> of the current branch on top of the given branch
    (this is called <em>replaying</em> the branch). Then it moves the
    branch pointer to point to this copy, so that you can pretend
    you moved it. Here's the real picture: <img src="image/real_rebase.png" alt="Real
    rebase"> The replayed commits should
    have new ids, not copies of the original ids. This allows you to
    still access the original commits using their old ids, if you
    really wanted to. In addition, the replayed commits should have
    new time stamps, allowing you to distinguish them from the
    originals in <code>global&#x2d;log</code>.</li>
  </ul></li>
</ul>

Rebase has one special case to look out for. If the current branch
pointer is in the history of the given branch, rebase just moves the
current branch to point to the same commit that the given branch
points to. No commits are replayed in this case.

There's one more point to make about rebase: If the commit at the
front of the given branch has files that have been modified since the
split point, these these changes should _propagate through_ the
replay. This means, essentially, that the versions of the files in the
given branch should take the place of their counterparts in the
replayed commits, up until one of the replayed commits has a version
of the file that had also been modified since the split point. In this
case, what you might expect to happen is that you would get conflicted
files, much like merge. However, for simplicity, we're not going to
have you deal with conflicts in rebase: in this case, just keep the
current branch's copies of the files. The bottom line: A file from the
given branch stops propagating through once it meets a modified file
in the replayed branch.

Finally, after successfully replaying nodes, reset to the node at the
front of the replayed branch.

By the way, if there are multiple branches after the split point, you
should NOT replay the other branches. For example, say we are on
branch <code>branch1</code> and we make the call <code>java gitlet.Main rebase master</code>:
<img src="image/branching_rebase.png" alt="Branching rebase">

<ul>
  <li><strong>Runtime</strong>: Should be linear relative to the history of the current
  branch and the given branch. Should also be linear in terms of the
  number of files added to both branches. Should also be linear
  relative to the total size of files added to the given branch. Also,
  be aware that rebase should not need to make any additional backup
  copies of files.</li>
  <li><strong>Failure cases</strong>: If a branch with the given name does not exist,
  print the error message <code>A branch with that name does not exist.</code> If
  the given branch name is the same as the current branch name, print
  the error message <code>Cannot rebase a branch onto itself.</code> If the input
  branch's head is in the history of the current branch's head, print
  the error message <code>Already up&#x2d;to&#x2d;date.</code></li>
  <li><strong>Dangerous?</strong>: Yes.</li>
  <li><strong>Differences from the real git</strong>: The real git's rebase is a
  complicated and many-flagged command. Gitlet's rebase really only
  gets at the core idea. In particular, the way it handles
  conflicts is much different! For instance, the real rebase will
  pause when it encounters a conflict, make the user fix it, and then
  continue on after.</li>
</ul>

-->

<!-- - __Our line count__: ~70 -->


<h2 id="e-miscellaneous-things-to-know-about-the-project">E. Miscellaneous Things to Know about the Project</h2>


<p>Phew! That was a lot of commands to go over just now. But don't worry,
not all commands are created equal. You can see for each command the
approximate number of lines we took to do each part (that this
only counts code specific to that command -- it doesn't double-count
code reused in multiple commands). You shouldn't worry about matching
our solution exactly, but hopefully it gives you an idea about the
relative time consumed by each command. Merge is
a lengthier command than the others, so don't leave it for the
last minute!</p>

<p>This is an ambitious project, and it would not be surprising for you
to feel lost as to where to begin.  Therefore, feel free to collaborate with
others a little more closely than usual, with the following caveats:</p>

<ul>
  <li>Acknowledge all collaborators in comments near the beginning of your
  <code>gitlet/Main.java</code> file.</li>
  <li>Don't share specific code; all collaborators must produce their own versions
  of the algorithms they come up with, so that we can see they differ.</li>
</ul>

<p>By now this spec has given you enough information to get
working on the project. But to help you out some more, there are a
couple of things you should be aware of:</p>


<h2 id="dealing-with-files">Dealing with Files</h2>

<p>This project requires reading and writing of files. In order to do
these operations, you might find the classes <code>java.io.File</code> and
<code>java.nio.file.Files</code> helpful. Actually, you may find various things
in the <code>java.io</code> and <code>java.nio</code> packages helpful. Be sure to read the
<code>gitlet.Utils</code> package for other things we've written for you.
If you do a little
digging through all of these, you might find a couple of methods that will
make the io portion of this project <em>much</em> easier! One warning: If
you find yourself using readers, writers, scanners, or streams,
you're making things more complicated than need be.</p>


<h2 id="serialization-details">Serialization Details</h2>

<p>If you think about Gitlet, you'll notice that you can only run one
command every time you run the program. In order to successfully
complete your version-control system, you'll need to remember the
commit tree across commands. This means you'll have to design not just a
set of classes to represent internal Gitlet structures during execution,
but you'll need a parallel representation as files within your <code>.gitlet</code>
directories, which will carry across multiple runs of your program.</p>

<p>As indicated earlier, the convenient way to do this is to serialize
the runtime objects that you will need to store permanently in files.
In Java, this simply involves implementing
the <code>java.io.Serializable</code> interface:</p>

<pre><code>import java.io.Serializable;

class MyObject implements Serializable {
    ...
}</code></pre>

<p>This interface has no methods; it simply marks its subtypes for the benefit
of some special Java classes for performing I/O on objects.  For example,</p>

<pre><code>import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;
...
    MyObject obj = ....;
    File outFile = new File(someFileName);
    try {
        ObjectOutputStream out =
            new ObjectOutputStream(new FileOutputStream(outFile));
        out.writeObject(obj);
        out.close();
    } catch (IOException excp) {
        ...
    }</code></pre>

<p>will convert <code>obj</code> to a stream of bytes and store it in the file whose
name is stored in <code>someFileName</code>.  The object may then be reconstructed with
a code sequence such as</p>

<pre><code>import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
...
    MyObject obj;
    File inFile = new File(someFileName);
    try {
        ObjectInputStream inp =
            new ObjectInputStream(new FileInputStream(inFile));
        obj = (MyObject) inp.readObject();
        inp.close();
    } catch (IOException | ClassNotFoundException excp) {
        ...
        obj = null;
    }</code></pre>

<p>The Java runtime does all the work of figuring out what fields need to be
converted to bytes and how to do so.</p>

<p>There is, however, one annoying subtlety to watch out for: Java serialization
follows pointers.  That is, not only is the object you pass into <code>writeObject</code>
serialized and written, but any object it points to as well.  If your internal
representation of commits, for example, represents the parent commits as
pointers to other commit objects, then writing the head of a branch will
write all the commits (and blobs) in the entire subgraph of commits
into one file, which is generally not what you want.  To avoid this,
don't use Java pointers to
refer to commits and blobs in your runtime objects, but instead use
SHA-1 hash strings.  Maintain a runtime map between these strings
and the runtime objects they refer to.  You create and fill in this map
while Gitlet is running, but never read or write it to a file.</p>

<p>You might find
it convenient to have (redundant) pointers commits as well as SHA-1 strings
to avoid the bother and execution time required to look them up each time.
You can store such pointers in your objects while still avoiding having them
written out by declaring them "transient", as in</p>

<pre><code>    private transient MyCommitType parent1;</code></pre>

<p>Such fields will not be serialized, and when back in and deserialized, will be
set to their default values (null for reference types).
You must be careful when reading the
objects that contain transient fields back in to set the transient fields to
appropriate values.</p>

<p>Unfortunately, looking at the serialized files your program has produced with
a text editor (for debugging purposes) would be rather unrevealing;
the contents are encoded in Java's
private serialization encoding.  We have therefore provided a simple debugging
utility program you might find useful: <code>gitlet.DumpObj</code>. See the Javadoc
comment on <code>gitlet/DumpObj.java</code> for details.</p>


<h2 id="f-testing">F. Testing</h2>


<p>As usual, testing is part of the project.  Be sure to provide
your own integration tests for each of the commands, covering all the specified
functionality.  Also add unit tests to <code>UnitTest.java</code> or other testing classes
it invokes in its <code>main</code> method.</p>

<p>We have provided a testing program that makes it relatively easy to write
integration tests: <code>testing/tester.py</code>.  As for Project #2, this interprets
testing files with an <code>.in</code> extension.
<br/>
Within the <code>testing</code> subdirectory, running the command</p>

<pre><code>python3 tester.py &#x2d;&#x2d;verbose FILE.in ...</code></pre>

<p>where <code>FILE.in ...</code> is a list of specific <code>.in</code> files you want to check, will
provide additional information, such as what your program is outputting.
The command</p>

<pre><code>python3 tester.py &#x2d;&#x2d;verbose &#x2d;&#x2d;keep FILE.in</code></pre>

<p>will, in addition, keep around the directory that <code>tester.py</code> produces so
that you can examine its files at the point the tester script detected an
error.</p>

<p>In effect, the tester implements a very simple <em>domain-specific language (DSL)</em>
that contains commands to</p>

<ul>
  <li>Set up or remove files from a testing directory;</li>
  <li>Run <code>java gitlet.Main</code>;</li>
  <li>Check the output of Gitlet against a specific output or a regular expression
  describing possible outputs;</li>
  <li><p>Check the presence, absence, and contents of files.
  Running the command</p>

  <p>python3 testing/tester.py</p></li>
</ul>

<p>(with no operands, as shown)
will provide a message documenting this language.
We've provided some examples in the directory <code>testing/samples</code>.  Don't
put your own tests in that subdirectory; the readers will not count those as your
tests.  Put all your <code>.in</code> files immediately within the <code>testing</code> directory.</p>

<p>As usual, we will test your code <em>on the the instructional machines</em>, so do
be sure it works there!  You can tell us how "it works on my machine" until you
are blue in the face; we heartlessly won't care about that.</p>

<p>We've added a few things to the makefile to adjust for differences in people's
setups.  If your system's command for invoking Python 3 is simply <code>python</code>, you
can still use our makefile unchanged by using</p>

<pre><code>  make PYTHON=python check</code></pre>

<p>You can pass additional flags to <code>tester.py</code> with, for example,</p>

<pre><code>  make TESTER_FLAGS=&quot;&#x2d;&#x2d;show=all &#x2d;&#x2d;keep&quot;</code></pre>


<h2 id="g-design-document-and-checkpoint">G. Design Document and Checkpoint</h2>


<p>Since you are not working from a substantial skeleton this time, we are
asking that everybody submit a design document describing their implementation
strategy.  It is not graded, but we will insist on having it before helping you
with bugs in your program.  Here are <a href="design.html">some guidelines</a>, as
well as an <a href="enigma-example.html">example from the Enigma project</a>.</p>

<p>There will be an initial checkpoint for the project, due <strong><em>April 27, 2020</em></strong>.
Submit it in your project 3 directory using the tag <code>proj3a&#x2d;</code><em>n</em> (where,
as usual, <em>n</em> is simply an integer.)  The checkpoint autograder will check
that</p>

<ul>
  <li>Your program compiles.</li>
  <li>You pass the sample tests from the skeleton: <code>testing/samples/*.in</code>.
  These require you to implement <code>init</code>, <code>add</code>, <code>commit</code>,
  <code>checkout &#x2d;&#x2d; [file name]</code>,
  <code>checkout [commit id] &#x2d;&#x2d;  [file name]</code>, and <code>log</code>.</li>
</ul>

<p>In addition, it will comment on (but not score):</p>

<ul>
  <li>Whether you pass style checks (it will ignore FIXME comments for now; we won't
  in the final submission.)</li>
  <li>Whether there are compiler warning messages.</li>
  <li>Whether you pass your own unit and integration tests (as run by <code>make check</code>).</li>
</ul>

<p>We <strong><em>will</em></strong> score these in your final submission.</p>


<h2 id="h-going-remote-extra-credit">H. Going Remote (Extra Credit)</h2>


<p>This project is all about mimicking git's local features. These are
useful because they allow you to backup your own files and maintain
multiple versions of them. However, git's true power is really in its
<em>remote</em> features, allowing collaboration with other people over the
internet. The point is that both you and your friend could be
collaborating on a single code base. If you make changes to the files,
you can send them to your friend, and vice versa. And you'll both have
access to a shared history of all the changes either of you have made.</p>

<p>To get extra credit, implement some basic remote commands:
namely <code>add&#x2d;remote</code>, <code>rm&#x2d;remote</code>, <code>push</code>, <code>fetch</code>, and <code>pull</code>
You will get 4 extra-credit points for completing them.
Don't attempt or plan for extra credit until you have completed the
rest of the project.</p>

<p>Depending on how flexibly you have designed the rest of the project,
4 extra-credit points
may not be worth the amount of effort it takes to do this section.
We're certainly not expecting everyone to do it.
Our priority will be in helping students complete the main project;
if you're doing the
extra credit, we expect you to be able to stand on your own a little
bit more than most students.</p>


<h2 id="the-commands">The Commands</h2>


<p>A few notes about the remote commands:</p>

<ul>
  <li>Execution time will not be graded. For your own edification, please don't
  do anything ridiculous, though.</li>
  <li>All the commands are significantly simplified from their git
  equivalents, so specific differences from git are usually not
  notated. Be aware they are there, however.</li>
</ul>

<p>So now let's go over the commands:</p>


<h4 id="add-remote">add-remote</h4>


<ul>
  <li><strong>Usage</strong>: `java gitlet.Main add-remote [remote name] [name of remote directory]/.gitlet</li>
  <li><strong>Description</strong>: Saves the given login information under the given
  remote name. Attempts to push or pull from the given remote name
  will then attempt to use this <code>.gitlet</code> directory.
  By writing, e.g.,
    java gitlet.Main add-remote other ../testing/otherdir/.gitlet
  you can provide tests of remotes that will work from all
  locations (on your home machine or within the grading program's software).
  Always use forward slashes in these commands. Have your program convert
  all the forward slashes into the path separator character (forward slash on
  Unix and backslash on Windows).  Java helpfully defines the class variable
  <code>java.io.File.separator</code> as this character.</li>
  <li><strong>Failure cases</strong>: If a remote with the given name already exists,
  print the error message: <code>A remote with that name already exists.</code>
  You don't have to check if the user name and server
  information are legit.</li>
  <li><strong>Dangerous?</strong>: No.</li>
</ul>


<h4 id="rm-remote">rm-remote</h4>


<ul>
  <li><strong>Usage</strong>: <code>java gitlet.Main rm&#x2d;remote [remote name]</code></li>
  <li><strong>Description</strong>: Remove information associated with the given remote
  name. The idea here is that if you ever wanted to change a remote
  that you added, you would have to first remove it and then re-add
  it.</li>
  <li><strong>Failure cases</strong>: If a remote with the
  given name does not exist, print the error message: <code>A remote with
  that name does not exist.</code></li>
  <li><strong>Dangerous?</strong>: No.</li>
</ul>


<h4 id="push">push</h4>


<ul>
  <li><strong>Usage</strong>: <code>java gitlet.Main push [remote name] [remote branch name]</code></li>
  <li><p><strong>Description</strong>: Attempts to append the current branch's commits to
  the end of the given branch at the given remote. Details:</p>

  <p>This command only works if the remote branch's head is in the
  history of the current local head, which means that the local
  branch contains some commits in the future of the remote branch.
  In this case, append the future commits to the remote branch.
  Then, the remote should reset to the front of the appended
  commits (so its head will be the same as the local head). This
  is called fast-forwarding.</p>

  <p>If the Gitlet system on the remote machine exists but does not
  have the input branch, then simply add the branch to the remote
  Gitlet.</p></li>
  <li><strong>Failure cases</strong>: If the remote branch's head is not in the history
  of the current local head, print the error message <code>Please pull down
  remote changes before pushing.</code>  If the remote <code>.gitlet</code> directory does not
  exist, print <code>Remote directory not found.</code></li>
  <li><strong>Dangerous?</strong>: No.</li>
</ul>


<h4 id="fetch">fetch</h4>


<ul>
  <li><strong>Usage</strong>: <code>java gitlet.Main fetch [remote name] [remote branch name]</code></li>
  <li><strong>Description</strong>: Brings down commits from the remote Gitlet repository into the
  local Gitlet repository. Basically, this copies all commits and blobs from the given
  branch in the remote repository (that are not already in the current
  repository) into a branch named <code>[remote name]/[remote branch name]</code> in the
  local <code>.gitlet</code> (just
  as in real Git), changing <code>[remote name]/[remote branch name]</code> to point
  to the head commit (thus copying the contents of the branch from the remote
  repository to the current one).  This branch is created in the local
  repository if it did not previously exist.</li>
  <li><strong>Failure cases</strong>: If the remote Gitlet repository does not have the given
  branch name, print the error message <code>That remote does not have that
  branch.</code>  If the remote <code>.gitlet</code> directory does not
  exist, print <code>Remote directory not found.</code>
  <!-- Need failure case for remote name not defined. --></li>
  <li><strong>Dangerous?</strong> No</li>
</ul>


<h4 id="pull">pull</h4>


<ul>
  <li><strong>Usage</strong>: <code>java gitlet.Main pull [remote name] [remote branch name]</code></li>
  <li><strong>Description</strong>: Fetches branch <code>[remote name]/[remote branch name]</code> as
  for the <code>fetch</code> command, and then merges that fetch into the current branch.</li>
  <li><strong>Failure cases</strong>: Just the failure cases of <code>fetch</code> and <code>merge</code>
  together.</li>
  <li><strong>Dangerous?</strong> Yes!</li>
</ul>


<h2 id="i-things-to-avoid">I. Things to Avoid</h2>


<p>There are few practices that experience has shown will cause you endless grief
in the form of programs that don't work and bugs that are very hard to find
and sometimes not repeatable ("Heisenbugs").</p>

<ol>
  <li>Since you are likely to keep various information in files (such as commits),
  you might be tempted to use apparently convenient file-system operations
  (such as listing a directory) to sequence through all of them.  Be
  careful.  Methods such as <code>File.list</code> and <code>File.listFiles</code> produce file
  names in an undefined order.  If you use them to implement the <code>log</code>
  command, in particular, you can get random results.</li>
  <li>Windows users especially should beware that the file separator character is
  <code>/</code> on Unix (or MacOS) and '\' on Windows.  So if you form file names in
  your program by concatenating some directory names and a file name together
  with explicit <code>/</code>s or <code>\</code>s, you can be sure that it won't work on one
  system or the other.  Java provides a system-dependent file separator
  character (<code>System.getProperty(&quot;file.separator&quot;)</code>), or you can use
  the multi-argument constructors to <code>File</code>.</li>
</ol>


<h2 id="j-acknowledgments">J. Acknowledgments</h2>


<p>Thanks to Alicia Luengo, Josh Hug, Sarah Kim, Austin Chen, Andrew
Huang, Yan Zhao, Matthew Chow, especially Alan Yao, Daniel Nguyen, and
Armani Ferrante for providing feedback on this project. Thanks to git
for being awesome.</p>

<p>This project was largely inspired by <a href="http://www.jayway.com/2013/03/03/git-is-a-purely-functional-data-structure/">this</a>
excellent article by Philip Nilsson.</p>

<p>This project was created by Joseph Moghadam.  Modifications for Fall 2015, Fall 2017, and Fall 2019 by
Paul Hilfinger.</p>
    </main></div>
</body>
</html>
