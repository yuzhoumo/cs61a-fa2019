<!DOCTYPE html>
<html>
<head>
    <title>Project 1 | CS 61B Spring 2020</title>
    <meta charset="UTF-8">

    


    <link href="https://fonts.googleapis.com/css?family=Open+Sans:300,400,600" rel="stylesheet" type="text/css">
    <link href="../../../assets/css/common.css" rel="stylesheet" type="text/css">
    <link href="../../../assets/css/lab.css" rel="stylesheet" type="text/css">
    <link href="../../../assets/css/highlight/styles/tomorrow.css" rel="stylesheet" type="text/css">
    
    <link href="../../../assets/css/proj.css" rel="stylesheet" type="text/css">

    <script src="../../../assets/js/jquery-1.12.4.min.js" type="text/javascript"></script>
    <script src="../../../assets/css/highlight/highlight.pack.js" type="text/javascript"></script> 
    <script src="../../../assets/js/sidebar.js" type="text/javascript"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script type="text/x-mathjax-config">
MathJax.Hub.Config({

    tex2jax: {inlineMath: [["$", "$"]]}
})
   
</script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_HTML-full"></script>
</head>
<body>
    <div class="navbar-top"><div id="navitems">
        <a href="../../../index.html"><div class="navitem">Main</div></a>
        <a href="../../../about.html"><div class="navitem">Course Info</div></a>
        <a href="../../../staff.html"><div class="navitem">Staff</div></a>
        <!--<a href="../../../assign.html"><div class="navitem">Assignments</div></a>-->
        <a href="../../../../../../auth.berkeley.edu/cas/login%3Fservice=https:%252F%252Finst.EECS.Berkeley.EDU%252F~cs61b%252Fsp20%252Fscreencasts.html" target="_blank"><div class="navitem">Screencasts</div></a>
        <a href="../../../../../../auth.berkeley.edu/cas/login%3Fservice=https:%252F%252Finst.EECS.Berkeley.EDU%252F~cs61b%252Fsp20%252Fcgi-bin%252Fcalnet-auth-scores.cgi.html" target="_blank"><div class="navitem">Scores</div></a>
        <a href="../../../resources.html"><div class="navitem">Resources</div></a>
        <a href="https://piazza.com/class/jkx2gta66436jq"><div class="navitem">Piazza</div></a>
    </div></div>
    <div id="sidebar">
        <div id="sidebar-content">
            <h3>Navigation</h3>
            <ul>
  <li><a href="index.html#introduction">Introduction</a></li>
  <li><a href="index.html#background">Background</a></li>
  <li><a href="index.html#describing-permutations">Describing Permutations</a></li>
  <li><a href="index.html#example">Example</a></li>
  <li><a href="index.html#input-and-output">Input and Output</a></li>
  <li><a href="index.html#editing-main">Editing Main</a></li>
  <li><a href="index.html#handling-errors">Handling Errors</a></li>
  <li><a href="index.html#testing">Testing</a></li>
  <li><a href="index.html#writing-unit-tests-amp-integration-tests">Writing Unit Tests &amp; Integration Tests</a></li>
  <li><a href="index.html#running-enigma-in-intellij">Running Enigma in IntelliJ</a></li>
  <li><a href="index.html#comparing-with-the-staff-solution">Comparing with the Staff Solution</a></li>
  <li><a href="index.html#extra-credit">Extra Credit</a></li>
  <li><a href="index.html#office-hours">Office Hours</a></li>
  <li><a href="index.html#checkpoint">Checkpoint</a></li>
  <li><a href="index.html#what-to-turn-in">What To Turn In</a></li>
  <li><a href="index.html#advice">Advice</a></li>
  <li><a href="index.html#common-bugs">Common Bugs</a></li>
</ul>
        </div>
    </div>
    <div id="content-container"><main id="content">
        <header class="title">Project 1: The Enigma</header>
        
<script type="text/x-mathjax-config">
	  MathJax.Hub.Config({
	    tex2jax: {inlineMath: [["$","$"]]}
	  });
	</script>
	<script type="text/javascript"
	   src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
	</script>


<h2 id="introduction">Introduction</h2>

<p>This programming assignment is intended to exercise a few useful data
structures and an object-based view of a programming problem. There is some
background reading, but the necessary program is not (or rather need not be)
terribly big. The <a href="https://www.youtube.com/playlist?list=PLe6eaTVou9VQoL5vGFJCH3r6bJbh04hao">video walkthrough</a> is located here.</p>

<p>We will be grading largely on whether you manage to get your
program to work (according to our tests).   In addition, we will
be looking at your own tests (which you should be sure to turn in as well).
While we have supplied a few unit tests and some simple integration tests and
testing utilities, the tests in the skeleton are entirely inadequate for testing
your program.  There is also a stylistic component: the
grading machinery require that your program pass a mechanized style
check (<code>style61b</code>), which mainly checks for formatting and the
presence of comments in the proper places. See the course website
for a brief description of the style rules. You may change <strong><em>any</em></strong> of the code we've
provided, as long as the
resulting program works according to the specifications here.</p>

<p>To obtain the skeleton files (and set up an initial entry for your
project in the repository), you can use the command sequence</p>

<pre><code>git fetch shared
git merge shared/proj1 &#x2d;m &quot;Get proj1 skeleton&quot;</code></pre>

<p>from your Git working directory.  Should we update the skeleton, you can use
exactly the same sequence to update your project with the same changes.</p>


<h2 id="background">Background</h2>

<p>You may have heard of the Enigma machines that Germany used during
World War II to encrypt its military communications.
If you have not, I recommend you read the
<a href="https://en.wikipedia.org/wiki/Enigma_machine">wikipedia page on them</a>, or similar resource,
especially the part about design and operation.
This project
involves building a simulator for a generalized version of this
machine (which itself had several different versions.)
Your program will take descriptions of possible
initial configurations of the machine and messages to encode or decode
(the Enigma algorithms were <em>reciprocal,</em> meaning that
encryption is its own inverse operation.)</p>

<p>The Enigmas effect a <em>substitution cipher</em> on the letters of a
message.  That is, at any given time, the machine performs a
permutation&mdash;a one-to-one mapping&mdash;of the alphabet onto itself.
The alphabet consists solely of the 26 letters in one case
(there were various conventions for spaces and punctuation).</p>

<p>Plain substitution ciphers are easy to break (you've probably seen
puzzles in newspapers that consist of breaking such ciphers).  The
Enigma, however, implements a <em>progressive</em> substitution, different
for each subsequent letter of the message.  This made decryption
considerably more difficult.</p>

<p>The device consists of a simple mechanical
system of (partially) interchangeable <em>rotors</em> (<em>Walzen</em>) that
sit side-by-side on a
shaft and make electrical contact with each other.
Most of these rotors have
26 contacts on both sides, which are wired together internally so as
to effect a permutation
of signals coming in from one side onto the
contacts on the other (and the inverse permutation when going in the
reverse direction).  To the left of the rotors, one could select
one of a set of reflectors (<em>Umkehrwalzen</em>), with contacts on their
right sides only, and wired to connect
half of those contacts to the other half.
A signal starting from
the rightmost rotor enters through one of the 26 possible contacts, flows through wires
in the
rotors, "bounces" off the reflector, and then comes back through the
same rotors (in reverse) by a different route, always ending up being permuted to a
letter position different from where it started; that is, the permutation was
always a <em>derangement</em>. (This was a significant
cryptographic weakness, as it turned out.  It doesn't really do a
would-be code-breaker any good to know that some letters in an
encrypted message <em>might</em> be the same as the those in the plaintext if he
doesn't know which ones. But it does a great deal of good to be able
to <em>eliminate</em> possible decryptions because some of their letters
are the same as in the plaintext.)</p>

<p>Each rotor and each reflector
implements a different permutation, and the overall effect
depends on their configuration: which rotors and reflector are used,
what order they are
placed in the machine, and which rotational position they are
initially set to.
This configuration is the first part of the secret key used to
encrypt or decrypt a message.
In what follows, we'll refer to the selected reflector and rotors in a machine's
configuration as 1 through <em>N</em>, with 1 being the reflector, and <em>N</em>
the rightmost rotor.  In our simulator, <em>N</em> will be a configuration parameter.
In actual Enigma machines, it was fixed for any given model (the Kreigsmarine (Navy) used
$N=5$ (four rotors and reflector) and the Wehrmacht used $N=4$.)</p>

<p>The overall permutation changes with each successive letter because some
of the rotors rotate after encrypting a letter.
Each rotor has a circular ratchet on its right side and
an "alphabet ring" on its left side that fits over the
ratchet of the rotor to its left.
Before a letter of a message is translated, a spring-loaded
pawl (lever)&mdash;one to the right
of each rotating rotor&mdash;tries
to engage the ratchet on the right side of its
rotor and thus rotate its rotor by one position,
changing the permutation performed by the rotor.
Thus, pawls always try to engage with the ratchet of their own rotor.
The lever on the
rightmost rotor (<em>N</em>) always succeeds, so that rotor <em>N</em> (the "fast" rotor)
rotates one position before each character.  The pawls pushing
the other rotors, however, are normally blocked from
engaging their rotors by the alphabet ring on the left side of the rotor to
their right. This <a href="https://observablehq.com/@tmcw/enigma-machine">interactive website</a> provides a good
visualization of how signals travel through the rotors and how messages
are encrypted. DISCLAIMER: This visualizer does not depict the underlying
details of how rotors rotate. It's just a tool that may help your
understanding of how the electrical signals propagate through the system.</p>

<p>This ring usually holds the pawl away from its own ratchet,
preventing the rotor wheel to its left from moving.
However, the rings have notches in them (either one or two in the
original Enigma machines), and when the pawl is
positioned over a notch in the ring for the rotor to its right,
it slips through to its own rotor and pushes it forward.
A "feature" of the design called "double stepping" (corrected in other
versions of the Enigma, since it reduced the period of the cipher)
is that when a pawl is in a notch, it also moves the notch itself and the
rotor the notch is connected to. Since the notch for rotor $i$ is connected to rotor $i$,
when the pawl of rotor $i - 1$ slips through into the notch for rotor $i$, rotors
on <strong><em>both</em></strong> sides of the pawl move (so rotor $i-1$ and rotor $i$ move).</p>

<p>Let's illustrate with a much simplified version.  Suppose our alphabet has
only the letters A-C and we have four rotors (numbered 1-4) each of which has
one notch on its ring at the C position.  Suppose also that there are 3
pawls, one for each of rotors 2-4. We will still refer to these as pawls 2-4,
to maintain that pawl $i$ belongs to rotor $i$. There is no pawl for
rotor 1, which will therefore not rotate.
We'll start with the rotors set at
AAAA.  The next 19 positions are as follows:</p>

<pre><code>AAAB  AAAC  AABA  AABB  AABC  AACA  ABAB  ABAC
ABBA  ABBB  ABBC  ABCA  ACAB  ACAC  ACBA  ACBB
ACBC  ACCA  AAAB</code></pre>

<p>As you can see,</p>

<ul>
  <li>Rotor 4, the fast rotor, advances each time, pushed by pawl 4.
  Rotor 4 has no rotor to its right, so there isn't a ring blocking it from engaging
  with its ratchet.</li>
  <li>Rotor 3 advances whenever Rotor 4 is at C.  Rotor 4 has a notch at C, so pawl 3
  can engage with the corresponding ratchet (the ratchet belonging to Rotor 3)
  and advance Rotor 3 by pushing on its ratchet. This would also rotate Rotor 4, since
  pawl 3 contacts its ratchet through the notch of Rotor 4, and therefore pushes
  the side of the notch when it moves.  However, since Rotor 4 always rotates anyway
  (because pawl 4 is always unblocked), this doesn't really change anything.</li>
  <li>Rotor 2 advances whenever Rotor 3 is at C, pushed by pawl 2. Rotor 3 has a notch
  at C, so pawl 2 slips into the notch and engages with its ratchet (the ratchet
  belonging to Rotor 2). Rotor 3 also advances when it is at C, because when
  pawl 2 is engaged through Rotor 3's notch it will push against that notch
  when it moves, moving Rotor 3, as well as moving Rotor 2 by pushing on Rotor 2's ratchet.</li>
  <li>There is no pawl 1, so Rotor 2 (unlike Rotor 3) does <strong><em>not</em></strong> advance just because
  it is at C.</li>
  <li>Rotor 1 never changes, since there is no pawl on either side of it.</li>
</ul>

<p>Each rotor can only advance at most one position per keypress.</p>

<p>So the advancement of the rotors, while similar to that of the wheels of an
odometer, is not quite the same.  If it were, then the next position after
AACA would be AACB, rather than ABAB.
Also, it would take 27 steps to return to the initial configuration instead of
18.</p>

<p>The effect of advancing a wheel is to change where on the wheel
any given signal enters or leaves.  When a wheel is in its 'A' setting
in the machine, then a signal that arrives from the right at, say,
the 'C' position,
goes into the 'C' contact on the wheel. Likewise, a signal that leaves
the wheel from its left 'C' contact exits at the 'C' position.  When the
wheel is rotated by one to its 'B' setting, a signal that arrives at
the 'C' position goes instead into the 'D' contact on the wheel, and a
signal that leaves through the 'D' contact does so at the 'C'
position.  It's easier to calculate if we use numbers 0--25 rather than
letters ('A' is 0, 'B' is 1, etc.).  Then, when the wheel is in its
$k$ setting, a signal entering at the $p$ position enters the $p+k
\bmod 26$ contact on the wheel, and a signal exiting through the $c$
contact does so at the $c - k \bmod 26$ position.
For example,
Figure 1 shows one of the rotors from the real Enigma machines (called
rotor "I") and the effect of moving from its 'A' to its 'B' setting.</p>

<p><img src="img/figure1.png" alt="Rotor Example"></p>

<blockquote><p><strong>Figure 1.</strong> Permutations performed by a rotor in its 'A' and 'B'
settings.  The italicized alphabets at the top and bottom indicate the letters
corresponding to the positions around the rotor.  The inner alphabets
indicate the positions along the rotor itself.  The rotor depicted was
designated 'I' in the original Enigma machine used by the German military.</p></blockquote>

<p>The
contacts on the rightmost rotor's right side connect with stationary
input and output contacts, which run to keys that, when pressed, direct
current to the contact from a battery or, when not pressed, direct
current back from the contact to a light bulb indicating a letter of the
alphabet.  Since a letter never encrypts or decrypts to itself after
going back and forth through the rotors, the
to and from directions never conflict.</p>

<p>The German Navy used a machine with 12 rotors and five slots for them:</p>

<ul>
  <li>Eight rotors labeled with roman numerals I--VIII, of which three will
  be used in any given configuration as the rightmost rotors,</li>
  <li>Two additional non-moving rotors (<em>Zusatzwalzen</em>) labeled "Beta" and "Gamma",     of which one will be used in any configuration, as the fourth-from-right
  rotor, and</li>
  <li>Two reflectors (<em>Umkehrwalzen</em>), labeled 'B' and 'C', of which one will
  be used in any given configuration as the leftmost rotor.</li>
</ul>

<p>Given just this equipment, there are 614,175,744 possible configurations (or
keys):</p>

<ul>
  <li>Two possible reflectors, times</li>
  <li>Two possible rotors in the fourth position, times</li>
  <li>$8!/(8-3)! = 336$ choices for the rightmost three rotors and their ordering, times</li>
  <li>$26^4$ possible initial rotational settings for the rightmost four rotors (each reflector had only one possible position.).</li>
</ul>

<p>Especially by today's standards, this is not a large key
size (less than 30 bits).  To make things more difficult for code-breakers,
therefore, the Enigma incorporated a plugboard (<em>Steckerbrett</em>) between
the keyboard and the rightmost wheel.  It acted as a non-moving, configurable
rotor.  The operator could choose any set of disjoint pairs of letters by means
of cables placed between them on the plugboard.  Each selected  pair would then be
swapped going into the machine from the keyboard and coming out into the
indicator lights.  Thus, if the operator connected ("steckered") the letters
A and P, then P would be substituted for each A typed and vice versa.  Likewise,
if an ingoing letter was encrypted to P by the other rotors, it would display
as A, and letters decrypted as A would display as P.</p>


<h2 id="describing-permutations">Describing Permutations</h2>

<p>Since the rotors and the plugboard implement permutations, we'll need a
standard way to describe them.  We could simply have a table showing each
letter and what it maps to, but we'll use a more compact notation
known as <em>cycle representation</em>.  The idea is that any permutation of a set may
be described as a set of <em>cyclic permutations</em>.  For example, the notation</p>

<pre><code>(AELTPHQXRU) (BKNW) (CMOY) (DFG) (IV) (JZ) (S)</code></pre>

<p>describes the permutation in Figure 1.  It describes seven cycles:</p>

<ul>
  <li>A maps to E, E to L, L to T, ..., R to U, and U back to A.</li>
  <li>B maps to K, K to N, N to W, and W back to B.</li>
  <li>C maps to M, M to O, O to Y, and Y back to C.</li>
  <li>D maps to F, F to G, and G back to D.</li>
  <li>I maps to V and V back to I.</li>
  <li>J maps to Z and Z back to J.</li>
  <li>S maps to itself.</li>
</ul>

<p>The inverse permutation just reverses these cycles:</p>

<ul>
  <li>U maps to R, R to X, ..., E to A, and A back to U.</li>
  <li>...</li>
  <li>S maps to itself.</li>
</ul>

<p>Each letter appears in one and only one cycle, so the mapping is unambiguous.
As a shorthand, we'll say that if a letter is left out of all cycles, it maps
to itself (so that we could have left off "(S)" In the example above.)</p>

<p>Figure 2 shows the permutations corresponding to the
rotors used in the German Navy's Enigma machine.</p>



<table>
  <tr>
    <th><strong>Rotor</strong></th>
    <th><strong>Permutation</strong> (as cycles)</th>
    <th><strong>Notch</strong></th>
  </tr>
  <tr>
    <td align="left">Rotor I</td>
    <td align="left">(AELTPHQXRU) (BKNW) (CMOY) (DFG) (IV) (JZ) (S)</td>
    <td align="left">Q</td>
  </tr>
  <tr>
    <td align="left">Rotor II</td>
    <td align="left">(FIXVYOMW) (CDKLHUP) (ESZ) (BJ) (GR) (NT) (A) (Q)</td>
    <td align="left">E</td>
  </tr>
  <tr>
    <td align="left">Rotor III</td>
    <td align="left">(ABDHPEJT) (CFLVMZOYQIRWUKXSG) (N)</td>
    <td align="left">V</td>
  </tr>
  <tr>
    <td align="left">Rotor IV</td>
    <td align="left">(AEPLIYWCOXMRFZBSTGJQNH) (DV) (KU)</td>
    <td align="left">J</td>
  </tr>
  <tr>
    <td align="left">Rotor V</td>
    <td align="left">(AVOLDRWFIUQ)(BZKSMNHYC) (EGTJPX)</td>
    <td align="left">Z</td>
  </tr>
  <tr>
    <td align="left">Rotor VI</td>
    <td align="left">(AJQDVLEOZWIYTS) (CGMNHFUX) (BPRK)</td>
    <td align="left">Z and M</td>
  </tr>
  <tr>
    <td align="left">Rotor VII</td>
    <td align="left">(ANOUPFRIMBZTLWKSVEGCJYDHXQ)</td>
    <td align="left">Z and M</td>
  </tr>
  <tr>
    <td align="left">Rotor VIII</td>
    <td align="left">(AFLSETWUNDHOZVICQ) (BKJ) (GXY) (MPR)</td>
    <td align="left">Z and M</td>
  </tr>
  <tr>
    <td align="left">Rotor Beta</td>
    <td align="left">(ALBEVFCYODJWUGNMQTZSKPR) (HIX)</td>
  </tr>
  <tr>
    <td align="left">Rotor Gamma</td>
    <td align="left">(AFNIRLBSQWVXGUZDKMTPCOYJHE)</td>
  </tr>
  <tr>
    <td align="left">Reflector B</td>
    <td align="left">(AE) (BN) (CK) (DQ) (FU) (GY) (HW) (IJ) (LO) (MP) (RX) (SZ) (TV)</td>
  </tr>
  <tr>
    <td align="left">Reflector C</td>
    <td align="left">(AR) (BD) (CO) (EJ) (FN) (GT) (HK) (IV) (LM) (PW) (QZ) (SX) (UY)</td>
  </tr>
</table>



<blockquote><p><strong>Figure 2.</strong> The rotors used in the Naval Enigma, showing the permutations they
implement and the point(s) at which there are notches that allow their
left neighbor rotor to advance.  Thus, when Rotor I is at 'Q' and the
machine advances, the rotor to the left of Rotor I will advance.  The
Beta and Gamma rotors and the reflectors do not rotate.  The
reflectors shown here are the "thin" versions of the reflectors used
in the naval M4 Enigma machine.  The B reflector together with the
Beta rotor in the 'A' position had the same effect as the usual
("thick") B reflector in the older three-rotor M3 Enigma machine
(likewise the C reflector with the Gamma rotor).  This allowed the M4
to encrypt and decrypt messages to and from M3 Enigmas.  Source:
<a href="http://www.codesandciphers.org.uk/enigma/rotorspec.htm">Tony Sale's pages</a>.</p></blockquote>


<h2 id="example">Example</h2>

<p>As an example of a translation, consider the set of rotors from
Figure 2, and suppose that</p>

<ul>
  <li>The rotors in positions 1--5 are, respectively, B, Beta, III, IV, and I.</li>
  <li>The rotors in positions 2--5 are currently at positions A, X, L, E,
  respectively.</li>
  <li>In the plugboard, the letter pair 'Y' and 'F' and the letter pair
  'Z' and 'H' are both interchanged.</li>
</ul>

<p>We input the letter 'Y',  which causes the following steps:</p>

<ol>
  <li>The pawls all move. This causes rotor 5 to advance from E to F.
  The other two pawls are not over notches, so rotors 3 and 4 do not
  move.</li>
  <li>The letter 'Y' enters the plugboard and is converted to 'F'.</li>
  <li>The letter 'F' enters the right side of rotor 5 (an I rotor) at position 5,
  since 'F' is the 5th letter of the alphabet numbering from 0.  Since the current
  setting of rotor 5 is 'F', the signal enters the rotor at position $5$,
  but hits contact $5+5=10$, or 'K'.</li>
  <li>According to Figure 2, rotor I converts 'K' to
  'N' (letter number 13).  Because the setting of rotor I is 'F', however,
  the signal actually comes out at letter position $13-5=8$ ('I').</li>
  <li>The 'I' signal from rotor 5 now goes into the right side of
  rotor 4.  Since rotor 4 is a IV rotor and is in the 'L' (or 11)
  setting, the 'I' enters at contact $8+11=19$ ('T'), and is
  translated to 'G' (6), which comes out at position $6-11=-5 = 21 \bmod 26$,
  the fifth letter from the end of the alphabet ('V').</li>
  <li>The 'V' from rotor 4 goes now to the right side of rotor 3, a
  III rotor in setting 'X' (23).  The signal enters the rotor at contact
  $21+23 = 44 = 18 \bmod 26$ ('S'), is translated to 'G' (6), which
  exits at position $6 - 23 = -17 = 9 \bmod 26$ ('J').</li>
  <li>Rotor 2 (Beta) is in position 'A', and thus translates 'J' to 'W'.</li>
  <li>Rotor 1 (B) converts the 'W' to 'H' and bounces it back to the
  left side of rotor 2.</li>
  <li>Rotor 2 (Beta in the 'A' position) converts 'H' on its left to
  'X' (23) on its right.</li>
  <li>The 'X' from rotor 2 now goes into the $23 + 23 = 46 = 20 \bmod
  26$ ('U') contact on the left side of rotor 3 (III in setting 'X'),
  and is converted to 'W' (22), which comes out at position
  $22-23=-1=25 \bmod 26$ ('Z') on the right side of rotor 3.</li>
  <li>'Z' now enters the left side of rotor 4 (IV in setting 'L') at
  $25+11=36=10 \bmod 26$ ('K'), and is translated to 'U' (20), which comes
  out at position $20 - 11=9$ ('J') on the right side of rotor 4.</li>
  <li>The 'J' from rotor 4 enters the left side of rotor 5 (I
  at setting 'F') at contact $9 + 5= 14$ ('O'), is translated to 'M'
  (12), and comes out at position $12 - 5 = 7$ ('H') on the right side
  of rotor 5.</li>
  <li>Finally,the letter 'H' is converted to 'Z' by the plugboard.</li>
</ol>

<p>Therefore, 'Y' is converted to 'Z'.</p>

<p>After a total of 12 characters are converted, the rotor settings will
have become 'AXLQ'.  Just before the next character is converted,
rotor 5 will advance to 'R' and, since its notch is at position 'Q',
rotor 4 will advance to 'M', so that the rotor configuration will be
'AXMR' before the 13th character is converted.  After an additional
597 characters have been converted, the configuration will be
'AXIQ'.  The character after that will advance rotor 5 to 'R' and
rotor 4 to 'J', giving 'AXJR'.  The next character will advance 5 to
'S',
and, since rotor IV's notch is at 'J', rotor 3 will advance to 'Y'.
Also, as rotor 3's pawl advances rotor 3, it also moves the notch on
rotor 4, advancing rotor 4 to 'K', so that the configuration goes from
'AXJR' to 'AYKS'. Rotor 3 in this case has a notch at 'V', but since
rotor 2 has no pawl, rotor 3's notch never has any effect.</p>


<h2 id="input-and-output">Input and Output</h2>

<p>To run your program on the command line, first compile all of your files with</p>

<pre><code>    javac &#x2d;g &#x2d;Xlint:unchecked enigma/*.java</code></pre>

<p>or, if you have it, just use</p>

<pre><code>    make</code></pre>

<p>After compiling, you can use the command</p>

<pre><code>    java &#x2d;ea enigma.Main [configuration file] [input file] [output file]</code></pre>

<p>to run your program.
The configuration file contains descriptions of the machine and the
available rotors. The data are in <em>free format</em>.  That is, they consist of
strings of non-whitespace characters separated by arbitrary whitespace (spaces,
tabs, and newlines), so that indentation, spacing, and line breaks
are irrelevant.  Each file has the following contents:</p>

<ul>
  <li>A string of the form $C_1C_2\cdots C_n$ where the $C_i$ are
  non-blank ASCII characters other than "<code>*</code>", "<code>(</code>" and "<code>)</code>".
  This is the alphabet of the machine, giving both the character set and the
  ordering of the characters around a rotor.  For the examples in this
  document, we use just the upper-case alphabet (as did the Enigma machines),
  but your solution must deal with general alphabets.
  In the following, we will generally refer to the characters in this alphabet
  as "letters", even when they include digits, punctuation, or other symbols.</li>
  <li>Two integer numerals, $S > P \ge 0$, where $S$ is the number of
  rotor slots (including the reflector)
  and $P$ is the number of pawls&mdash;that is,
  the number of rotors that move.  The moving rotors and their pawls
  are all to the right of any non-moving ones.</li>
  <li><p>Any number of rotor descriptors.  Each has the following components (separated
  by whitespace):</p>

  <ul>
    <li>A name containing any non-blank characters other than parentheses.</li>
    <li>One of the characters R, N, or M, indicating that the rotor is a
    reflector, a non-moving rotor, or a moving rotor, respectively.
    Non-moving rotors can only be used in positions $2$ through $S-P$
    and moving rotors in positions $S-P+1$ through $S$.</li>
    <li>Immediately after the M for a moving rotor come(s) the letter(s)
    at which there is a notch on the rotor's ring (no space between
    M and these letters).</li>
    <li>The cycles of the permutation, using the notation discussed above.</li>
  </ul></li>
</ul>

<p>For example, the German Naval Enigma machine might be described with
this configuration file (see Figure 2):</p>

<pre><code>          ABCDEFGHIJKLMNOPQRSTUVWXYZ
          5 3
          I MQ      (AELTPHQXRU) (BKNW) (CMOY) (DFG) (IV) (JZ) (S)
          II ME     (FIXVYOMW) (CDKLHUP) (ESZ) (BJ) (GR) (NT) (A) (Q)
          III MV    (ABDHPEJT) (CFLVMZOYQIRWUKXSG) (N)
          IV MJ     (AEPLIYWCOXMRFZBSTGJQNH) (DV) (KU)
          V MZ      (AVOLDRWFIUQ)(BZKSMNHYC) (EGTJPX)
          VI MZM    (AJQDVLEOZWIYTS) (CGMNHFUX) (BPRK)
          VII MZM   (ANOUPFRIMBZTLWKSVEGCJYDHXQ)
          VIII MZM  (AFLSETWUNDHOZVICQ) (BKJ) (GXY) (MPR)
          Beta N    (ALBEVFCYODJWUGNMQTZSKPR) (HIX)
          Gamma N   (AFNIRLBSQWVXGUZDKMTPCOYJHE)
          B R       (AE) (BN) (CK) (DQ) (FU) (GY) (HW) (IJ) (LO) (MP)
                    (RX) (SZ) (TV)
          C R       (AR) (BD) (CO) (EJ) (FN) (GT) (HK) (IV) (LM) (PW)
                    (QZ) (SX) (UY)</code></pre>

<p>The input file to your program will consist of a sequence of messages to
decode, each preceded by a line giving the initial settings.
Given the configuration file above, a settings line looks like this:</p>

<pre><code>* B Beta III IV I AXLE (YF) (ZH)</code></pre>

<p>The asterisk must appear in the first column.
Other items on the line may be separated from each other by tabs and blanks;
adjacent items that are rotor names or consist entirely of letters from the
alphabet must be so separated.
This particular example means that the rotors used are reflector B,
and rotors Beta, III, IV, and I, with rotor I in the rightmost, or fast,
slot.  The remaining parenthesized items indicate that the letter pair
Y and F and the pair Z and M are steckered (swapped going in from
the keyboard and going out to the lights).</p>

<p>In general for this particular configuration,
rotor 1 is always the reflector; rotor 2 is Beta or
Gamma, and each of 3-5
is one of rotors I-VIII. A rotor may not be repeated.  The four letters
of the following word (AXLE in the example)
give the initial positions of rotors 2-5,
respectively (i.e., not including the reflector).  Any number of steckered pairs
may follow (including none).</p>

<p>After each settings line comes a message on any number of lines.
Each line of a message
consists only of letters (here meaning characters from the specified alphabet),
spaces,
and tabs (0 or more).
The program should ignore the blanks and tabs.
The end of message is indicated either by the
end of the input or by a new configuration line (distinguished by its
leading asterisk).
The machine is not reset between lines, but continues stepping from
where it left off on the previous message line.
Because the Enigma is a reciprocal cipher, a given translation may
either be a decryption or encryption; you don't have to worry about
which, since the process is the same in any case.</p>

<p>Output the translation for each message line
in groups of five characters, separated
by a space (the last group may have fewer characters, depending on the
message length). Figure 3 contains an example
that shows an encryption followed by a decryption
of the encrypted message. Since we have yet to cover the details of
File I/O, you will be provided the File IO machinery for this project.</p>

<pre>
             <b>Input</b>                              |         <b>Output</b>
* B Beta III IV I AXLE (HQ) (EX) (IP) (TR) (BY) | QVPQS OKOIL PUBKJ ZPISF XDW
FROM HIS SHOULDER HIAWATHA                      | BHCNS CXNUO AATZX SRCFY DGU
TOOK THE CAMERA OF ROSEWOOD                     | FLPNX GXIXT YJUJR CAUGE UNCFM KUF
MADE OF SLIDING FOLDING ROSEWOOD                | WJFGK CIIRG XODJG VCGPQ OH
NEATLY PUT IT ALL TOGETHER                      | ALWEB UHTZM OXIIV XUEFP RPR
IN ITS CASE IT LAY COMPACTLY                    | KCGVP FPYKI KITLB URVGT SFU
FOLDED INTO NEARLY NOTHING                      | SMBNK FRIIM PDOFJ VTTUG RZM
BUT HE OPENED OUT THE HINGES                    | UVCYL FDZPG IBXRE WXUEB ZQJO
PUSHED AND PULLED THE JOINTS                    | YMHIP GRRE
   AND HINGES                                   | GOHET UXDTW LCMMW AVNVJ VH
TILL IT LOOKED ALL SQUARES                      | OUFAN TQACK
   AND OBLONGS                                  | KTOZZ RDABQ NNVPO IEFQA FS
LIKE A COMPLICATED FIGURE                       | VVICV UDUER EYNPF FMNBJ VGQ
IN THE SECOND BOOK OF EUCLID                    |
                                                | FROMH ISSHO ULDER HIAWA THA
* B Beta III IV I AXLE (HQ) (EX) (IP) (TR) (BY) | TOOKT HECAM ERAOF ROSEW OOD
QVPQS OKOIL PUBKJ ZPISF XDW                     | MADEO FSLID INGFO LDING ROSEW OOD
BHCNS CXNUO AATZX SRCFY DGU                     | NEATL YPUTI TALLT OGETH ER
FLPNX GXIXT YJUJR CAUGE UNCFM KUF               | INITS CASEI TLAYC OMPAC TLY
WJFGK CIIRG XODJG VCGPQ OH                      | FOLDE DINTO NEARL YNOTH ING
ALWEB UHTZM OXIIV XUEFP RPR                     | BUTHE OPENE DOUTT HEHIN GES
KCGVP FPYKI KITLB URVGT SFU                     | PUSHE DANDP ULLED THEJO INTS
SMBNK FRIIM PDOFJ VTTUG RZM                     | ANDHI NGES
UVCYL FDZPG IBXRE WXUEB ZQJO                    | TILLI TLOOK EDALL SQUAR ES
YMHIP GRRE                                      | ANDOB LONGS
GOHET UXDTW LCMMW AVNVJ VH                      | LIKEA COMPL ICATE DFIGU RE
OUFAN TQACK                                     | INTHE SECON DBOOK OFEUC LID
KTOZZ RDABQ NNVPO IEFQA FS                      |
VVICV UDUER EYNPF FMNBJ VGQ                     |
</pre>

<center> <strong>Figure 3.</strong> Sample input and output (using the Naval cipher). </center>


<h2 id="editing-main">Editing Main</h2>


<p>Within <code>Main.java</code>, you will be working with Scanners. We
recommend that before you tackle this portion of the project
you do homework 3, as there will substantial practice on that
assignment. Inside of <code>Main.java</code> you will deal with a substantial
amount of input handling (involving both valid and invalid inputs). Do
not assume that all of your inputs will be well-formed and do your
best to make sure that you handle all cases where the input is not
what is expected.</p>

<p>In addition to this, in <code>Main.java</code>, you will need to print output in
a way that matches our sample output file. The Unix convention is that every
line ends with a newline (we say that newline is a <em>line terminator</em>
rather than a <em>line separator</em>), so
make sure that your output file also includes a newline at the end.
If your output seems exactly the
same as the grader's, but you are failing a test, chances are that
there is a newline error.</p>


<h2 id="handling-errors">Handling Errors</h2>

<p>You can see a number of opportunities for input errors:</p>

<ul>
  <li>The configuration file may have the wrong format.</li>
  <li>The input might not start with a setting.</li>
  <li>The setting line can contain the wrong number of arguments.</li>
  <li>The rotors might be misnamed.</li>
  <li>A rotor might be repeated in the setting line.</li>
  <li>The first rotor might not be a reflector.</li>
  <li>The initial positions string might be the wrong length or contain
  characters not in the alphabet.</li>
  <li>Messages containing characters from outside the alphabet.</li>
</ul>

<p>A significant amount of a program will typically be devoted to
detecting such errors, and taking corrective action.  In our case, the
main program is set up in such a way that the
only corrective action needed is to throw an <code>EnigmaException</code>
with an explanatory message.
The existing code in the main program will catch this exception,
print its message, and exit with a standard Unix error indication.
The skeleton supplies a simple static utility method, <code>error</code>, which
provides a convenient way to create error exceptions.  There are examples of its
use in the skeleton.</p>


<h2 id="testing">Testing</h2>

<p>The directory <code>testing</code> contains the scripts <code>test&#x2d;correct</code> and <code>test&#x2d;error</code>
for testing the execution of <code>enigma.Main</code>.</p>

<ul>
  <li><code>bash test&#x2d;correct</code> <em>F1</em>.in <em>F2</em>.in ... will run the program for each of
  the message files <em>F1</em>.in, <em>F2</em>.in ..., comparing the results to the
  corresponding output files <em>F1</em>.out, <em>F2</em>.out, ....  The configuration
  files used are <em>F1</em>.conf, <em>F2</em>.conf, .... However, if any of these is missing,
  the file <code>default.conf</code> (from the same directory as the input file) is used instead.</li>
  <li><code>bash test&#x2d;error</code> <em>F1</em>.in <em>F2</em>.in ... will run the program for each of
  the message files <em>F1</em>.in, <em>F2</em>.in ..., checking that the program
  reports at least one error in each case.  The configuration
  files are as for <code>test&#x2d;correct</code>.</li>
</ul>

<p>This needs to be run in your <code>proj1</code> directory, with paths to <code>test&#x2d;correct</code>
and input files. For example:</p>

<pre><code>     bash testing/test&#x2d;correct testing/correct/trivial1.in</code></pre>

<p>The tests we've supplied are nowhere near adequate to test your program, so you
will need to generate your own integration tests as well as unit tests (we will check
to see that you make an effort to test).</p>


<h2 id="writing-unit-tests-amp-integration-tests">Writing Unit Tests &amp; Integration Tests</h2>

<p>A (non-conclusive) video guide on how to test is given <a href="https://www.youtube.com/playlist?list=PLxrrsBRfM4tUQCbl1m3kVdYJpIB8-9AMG">here</a>.</p>

<p>Note about the video guide: The point in the spec in Vid #3 was: "A rotor might 
be repeated in the setting line.” Upon checking the AG tests, it turns out 
this line was meant for the .in file and your solution DOES NOT need to 
account for repetitions in the .conf file. <strong>To be clear, .conf would not 
be tested for repetitions so it is okay if your code can't handle that.</strong></p>

<p>We recommend you write unit tests for each class you write.
We have provided you the files <code>PermutationTest.java</code> and
<code>MovingRotorTest.java</code>, but if you create new files outside of that,
make sure to link it in <code>UnitTest.java</code>.  <a href="../../lab/lab6/index.html">Lab 6</a>
will provide resources on how to go about writing unit tests and
integration tests for Enigma, and will specifically walk you through
writing tests for Permutation and using <code>staff&#x2d;enigma</code> to help generate
your own integration tests.</p>


<h2 id="running-enigma-in-intellij">Running Enigma in IntelliJ</h2>


<p>As touched upon above, you can run your program on the command line.
In this section, we will cover how to run Enigma on IntelliJ with
input and output files.</p>

<p>Navigate to the Main class in your project. Try clicking the green
play button next to the <code>main</code> method in Main, and select 'Run
Main.main()'. If you haven't previously inputted arguments, you should
see an error like this:</p>

<p><img src="img/argerror.png" alt="No Argument Error"></p>

<p>We got this error because we haven't passed in any arguments to the
program! Notice that between 1 and 3 arguments can be passed in:</p>

<ul>
  <li>ARGS[0] is the name of a configuration file.</li>
  <li>ARGS[1] names an input file containing messages.</li>
  <li>ARGS[2] names an output file for processed messages.</li>
</ul>

<p>At the top right hand side of your screen, you should see a dropdown
menu now labeled Main. You should click the dropdown and select 'Edit
Configurations...'</p>

<p><img src="img/editconfig.png" alt="Edit Configurations"></p>

<p>A window should pop up, and you should be able to enter in your
arguments in the Program Arguments bar. For this example, create a
file called <code>riptide.in</code> in your testing/correct/ directory with the
following contents:</p>

<pre><code>* B Beta I II III AAAA (TD) (KC) (JZ)
I WAS SCARED OF CODING IN JAVA
I WAS SCARED OF USING GIT
AND STARTING ALL THESE PROJECTS
COMPILER KEEPS GETTING MAD AT ME
NOW MY PROJECT ONLY RUNS IN MY DREAMS
OH OH ALL THESE MERGE CONFLICTS</code></pre>

<p>If you've copied the file into your directory, you should be able to
refer to your <code>default.conf</code> configuration file and the <code>riptide.in</code>
file. Make sure you specify the correct path to your files, with
respect to your Working Directory.</p>

<p><img src="img/addargs.png" alt="Program Arguments"></p>

<p>This is equivalent to specifying the program arguments as such:</p>

<pre><code>java &#x2d;ea enigma.Main [configuration file] [input file] [output file]</code></pre>

<p>Now run <code>Main.main()</code>. We haven't specified an output file, so you
should see the output of your machine in standard output. If you're
wondering, you've just encrypted a verse in the <a href="https://www.youtube.com/watch?v=jXY5rRAXhFQ">Summer 2017 CS61BL
Musical</a>!</p>

<p>As a reference, you should see output like below. You're welcome to
make a new output file and add that to your program arguments if you
prefer.</p>

<p><img src="img/riptideout.png" alt="Expected Output"></p>

<p>We encourage you to write more of your own input and configuration
files and test them as above. We expect that you have added
adequate unit tests and additional integration tests beyond those
provided in the skeleton.</p>


<h2 id="comparing-with-the-staff-solution">Comparing with the Staff Solution</h2>


<p>You can run tests on the staff solution by ssh-ing into your instructional 
account and running <code>staff&#x2d;enigma &lt;conf file&gt; &lt;input file&gt;</code>. 
In order to redirect your output to a certain file you can add <code>&gt;&gt; filename</code>
at the end of each command, for example, 
<code>staff&#x2d;enigma &lt;conf file&gt; &lt;input file&gt; &gt;&gt; file1.out</code></p>

<p>To compare your files with the staff files, you can run 
<code>sdiff file1 file2</code> or use an online <a href="https://www.diffchecker.com/">diffchecker</a>.</p>


<h2 id="extra-credit">Extra Credit</h2>

<p>If after completing your solution, you are for some reason hankering for more,
you can, for 2 points of extra credit, implement the last missing piece of the Enigma:
the ring setting (<em>Ringstellung</em>). The alphabet rings are so called because
they are marked with the letters of the alphabet. It is these letters that
appear in the panel of the machine and indicate the current settings
of the rotors. In the real Enigma, the rotors' rings are adjustable.
Think of the positions on a rotor as being numbered
from 0, with 0 being the usual position of the first letter of the alphabet on
the ring.  The ring can be turned so as to make any letter of the alphabet
correspond to that 0 position instead.  If, for example, we have the usual
upper-case alphabet and we set the ring of rotor III
so that "B" is at the 0 position, then when the setting of that rotor is "B",
the rotor will convert "J" to "T", just as that rotor would normally translate
"J" when in the "A" position.  Likewise, when at the "D" setting, it would
translate as it normally would in the "C" setting.</p>

<p>Besides affecting the meaning of the rotor settings, the alphabet ring also
carries the notches that allow adjacent rotors to move.  The III
rotor, for example, has a notch at its "V" position.  Normally, this
comes into play when the rotor is at its 21 position, since "V" is letter
number 21 in the alphabet (numbering from 0).  But when the alphabet ring is
set so that "B" is at the 0 position, the notch occurs at the rotor's 20
position.</p>

<p>To specify the ring setting, we add an additional string to the configuration
line.  For example, the line</p>

<pre><code> * B Beta III IV I AXLE AAAA (BQ)</code></pre>

<p>is the same as what we have been writing as</p>

<pre><code> * B Beta III IV I AXLE (BQ)</code></pre>

<p>That "AAAA" is the (optional) ring setting; for the usual alphabet,
"AAAA" is the default setting.  The reflector (B) does not have an
adjustable ring.  The line</p>

<pre><code> * B Beta III IV I AXLE BEAR (BQ)</code></pre>

<p>says that the ring setting of the Beta rotor is "B", the III rotor is "E",
IV is "A", and I is "R".</p>

<p>Your solution must still handle configuration lines without the ring setting.</p>


<h2 id="office-hours">Office Hours</h2>

<p>For office hours debugging, we will stick to the following norms.</p>

<ul>
  <li>Course staff will spend at most ~10 minutes per student.</li>
  <li>You must provide a useful description of your question, or the staff
  may choose to help another person on the queue that does have one.
  <strong><em>Please preface your question with one of the following 4 sections of
  the project: Permutations, Rotors, Machine, Main.</em></strong></li>
  <li>Your code must be well documented, including all methods you write,
  according to the style guide. This is to minimize time spent verbally
  explaining what each method does.</li>
  <li>Your code must be well organized and explainable. It is not a good
  use of your time or the TAs’ time to try to find bugs in something
  that is disorganized and brittle.  When we do provide debugging help,
  it may be at a high level, where we suggest ways to reorganize your
  code in order to make clarity and debugging easier.</li>
  <li>If your question is for debugging help, you must be prepared to
  explain the error that is being caused and have a test or input that
  can easily reproduce the bug for ease of debugging. If you come to us
  saying something does not work, but have not written any tests or
  attempted to use the debugger, we will not help you. Saying "I am
  failing test X" is not an explanation of the error that is being
  caused.  Where is it happening? What is the type of error? What led up
  to this?</li>
  <li>We will attempt to group students in office hours to reduce queue
  time.  This means you should talk to your surrounding
  neighbors and discuss possible approaches to each other's bugs. You
  may not get 1-on-1 debugging help at peak office hours times, but a
  high level plan of attack to identify and narrow down the causes of
  your bug.</li>
</ul>


<h2 id="checkpoint">Checkpoint</h2>


<p>By <strong>Tuesday, March 3, (3/3)</strong> you must have completed the
following in order to receive <strong>2 points of extra credit</strong>.</p>

<ol>
  <li>Completed this <a href="https://www.gradescope.com/courses/82953/assignments/366107">quiz</a>.
  	You do not need to answer all questions correctly to receive full points, but you should
  understand all of the correct answers by the time you start coding.
  Feel free to ask any questions you have about the quiz in office
  hours, but please refrain from revealing answers on Piazza.</li>
  <li><p>Have made some changes to the <code>Permutations</code> and <code>Rotors</code> parts of
  the project. T his involves significant edits being made in the
  following files:</p>

<pre><code>&#x2d; `Permutations.java`
&#x2d; `Rotor.java`
&#x2d; `MovingRotor.java`
&#x2d; `Reflector.java`
&#x2d; `FixedRotor.java`</code></pre></li>
  <li><strong>All of your code compiles</strong>.</li>
</ol>

<p>Submit to the checkpoint by committing it and tagging it as follows (note the
tag is proj1a not proj1):</p>

<pre><code>git tag proj1a&#x2d;0     # Or proj1a&#x2d;1, etc.
git push
git push &#x2d;&#x2d;tags</code></pre>


<h2 id="what-to-turn-in">What To Turn In</h2>


<ol>
  <li>You should commit and push your completed project with the commit you want graded
  tagged and tags pushed. Your submission
  should contain no debugging print statements upon submission.</li>
  <li>Your program must pass the style checker with <strong><em>0</em></strong> errors. This
  includes adequately commenting all methods. Use the command <code>make style</code>
  to run style check locally on all your files. Do not use the IntelliJ 
  stylechecker plugin.</li>
  <li>You should have added adequate unit tests, both for the provided methods
  and any additional methods you write. We say "adequate" because the
  amount may change depending on how many additional methods you write
  or how rigorous each test is.  You will know if your test suite is
  adequate.</li>
  <li>You should have added additional integration tests beyond those provided
  in the skeleton.  Again, the exact number is not specified, but we
  recommend having enough that you feel confident that passing them means
  your program is correct.</li>
</ol>


<h2 id="advice">Advice</h2>

<p>First, get started immediately, of course.  Don't just jump in and
code, though.  Make sure you understand the specifications
(which have their subtleties) and
plan out how you're going to meet them. Read the skeleton code and understand the design.
Figure out how to break this
problem down into small pieces, and how to implement and test them one
piece at a time.  Know in detail how you're going to do something
before writing a line of Java code for it.  In particular, take some
time to understand how the rotors work, and especially how the rotor
position modifies the permutation.
You might find our staff solution or Loise Dade's <a href="http://enigma.louisedade.co.uk">Enigma Machine Emulator</a>
useful in understanding the Enigma's workings (and for
preparing your own test cases).</p>

<p>Don't allow things to remain mysterious to you, or they'll surely bite
you at some point.   You don't have to use <em>any</em> of the skeleton
code we've provided as long as the command <code>java enigma.Main</code>
works as specified.  However, if you find yourself throwing something
away because you don't understand it, <em>STOP!</em> You're allowing
yourself to be mystified by something that is intended to be simple.</p>

<p>There is a fair amount of string-hacking involved.
The Java library can help you.  Look at the documentation of
<code>String</code>,  <code>HashMap</code>, <code>ArrayList</code>, and <code>Scanner</code>
in the on-line Java library documentation.
We particularly invite you to consider the constructors and the methods</p>

<center>


<table>
  <tr>
    <th>From String</th>
    <th>From ArrayList</th>
    <th>From HashMap</th>
    <th>From Scanner</th>
  </tr>
  <tr>
    <td>charAt</td>
    <td>add</td>
    <td>get</td>
    <td>next</td>
  </tr>
  <tr>
    <td>replaceAll</td>
    <td>get</td>
    <td>put</td>
    <td>nextInt</td>
  </tr>
  <tr>
    <td>split</td>
    <td>size</td>
    <td></td>
    <td>hasNext()</td>
  </tr>
  <tr>
    <td>startsWith</td>
    <td></td>
    <td></td>
    <td>hasNext(...)</td>
  </tr>
  <tr>
    <td>substring</td>
    <td></td>
    <td></td>
    <td>nextLine</td>
  </tr>
  <tr>
    <td>toUpper</td>
    <td></td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td>trim</td>
    <td></td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td>indexOf</td>
    <td></td>
    <td></td>
    <td></td>
  </tr>
</table>


</center>

<p>Be creatively lazy.  Feel free to browse the Java library for useful
stuff, even if you haven't seen it in class.
If you find yourself writing:</p>

<pre><code>if (rotor.equals(&quot;I&quot;) {
    if (c == &#x27;A&#x27;)
        e = &#x27;E&#x27;;
    else if (c == &#x27;B&#x27;)
        e = &#x27;K&#x27;;
    ...
}</code></pre>

<p>or something equally hideous, <strong><em>STOP!</em></strong> you are doing something wrong!</p>

<p>You can write JUnit tests and integration tests (see the <code>testing</code> directory)
<em>before</em> you write a
line of code.
Be particularly careful to include tests that at one point caused your
program to fail (<em>regression tests</em>) so that you can be sure you
don't backslide when you make further changes. There's no reason you
can't have tests that you fail, by the way; they'll serve to remind
you of things you still need to do.</p>

<p>Use the git repository.  <strong><em>Frequently</em></strong> commit your work so that you'll never
have to reconstruct too much if your files somehow vanish
mysteriously.</p>

<p>Above all, it is always fair to ask for help and advice.  We don't
<strong><em>ever</em></strong> want to hear about how you've been beating your head
against the wall over some problem for hours.  If you can't make
progress, don't waste your time guessing or bleeding: ask.  If
nobody's available to ask, do something else (or get some sleep).</p>

<p>A Plan of Attack some TAs found useful was</p>

<ul>
  <li>Write tests for permutations, then all code for <code>Permutations</code>.</li>
  <li>Write tests for rotors, then all code for the various <code>Rotor</code> classes,
  going from least specific to most.</li>
  <li>Write code for <code>Machine</code>, creating tests as you account for various edge
  cases or error cases while coding.</li>
  <li>Finally, finish <code>Main</code>, again adding tests for various edge cases as you go.</li>
</ul>


<h2 id="common-bugs">Common Bugs</h2>


<ol>
  <li><code>%</code> in Java is remainder, and has different behavior from what you
  might expect with negative numbers.  Please see the provided method
  <code>wrap</code> for modular conversions, or see what the body of <code>wrap</code> does
  and replicate this if you prefer to use your own methods.</li>
</ol>
    </main></div>
</body>
</html>
